// DMS_WinErrorMsg.cpp : Implementation of DMS_WinErrorMsg
#include "stdafx.h"
#include "DMS_WinError.h"
#include "DMS_WinErrorMsg.h"

/////////////////////////////////////////////////////////////////////////////
// DMS_WinErrorMsg


STDMETHODIMP DMS_WinErrorMsg::GetErrorString(int nErrorCode, BSTR *sErrorString)
{
    CComBSTR            sTempString;

    switch (nErrorCode)
        {
        case    -8 :  sTempString   = _T("LZERROR_UNKNOWNALG"); break;
        case    -7 :  sTempString   = _T("LZERROR_BADVALUE"); break;
        case    -6 :  sTempString   = _T("LZERROR_GLOBLOCK"); break;
        case    -5 :  sTempString   = _T("LZERROR_GLOBALLOC"); break;
        case    -4 :  sTempString   = _T("LZERROR_WRITE"); break;
        case    -3 :  sTempString   = _T("LZERROR_READ"); break;
        case    -2 :  sTempString   = _T("LZERROR_BADOUTHANDLE"); break;
        case    -1 :  sTempString   = _T("LZERROR_BADINHANDLE"); break;
        case     0 :  sTempString   = _T("The operation completed successfully.  ERROR_SUCCESS"); break;
        case     1 :  sTempString   = _T("Incorrect function.  ERROR_INVALID_FUNCTION"); break;
        case     2 :  sTempString   = _T("The system cannot find the file specified.  ERROR_FILE_NOT_FOUND"); break;
        case     3 :  sTempString   = _T("The system cannot find the path specified.  ERROR_PATH_NOT_FOUND"); break;
        case     4 :  sTempString   = _T("The system cannot open the file.  ERROR_TOO_MANY_OPEN_FILES"); break;
        case     5 :  sTempString   = _T("Access is denied.  ERROR_ACCESS_DENIED"); break;
        case     6 :  sTempString   = _T("The handle is invalid.  ERROR_INVALID_HANDLE"); break;
        case     7 :  sTempString   = _T("The storage control blocks were destroyed.  ERROR_ARENA_TRASHED"); break;
        case     8 :  sTempString   = _T("Not enough storage is available to process this command.  ERROR_NOT_ENOUGH_MEMORY"); break;
        case     9 :  sTempString   = _T("The storage control block address is invalid.  ERROR_INVALID_BLOCK"); break;
        case    10 :  sTempString   = _T("The environment is incorrect.  ERROR_BAD_ENVIRONMENT"); break;
        case    11 :  sTempString   = _T("An attempt was made to load a program with an incorrect format.  ERROR_BAD_FORMAT"); break;
        case    12 :  sTempString   = _T("The access code is invalid.  ERROR_INVALID_ACCESS"); break;
        case    13 :  sTempString   = _T("The data is invalid.  ERROR_INVALID_DATA"); break;
        case    14 :  sTempString   = _T("Not enough storage is available to complete this operation.  ERROR_OUTOFMEMORY"); break;
        case    15 :  sTempString   = _T("The system cannot find the drive specified.  ERROR_INVALID_DRIVE"); break;
        case    16 :  sTempString   = _T("The directory cannot be removed.  ERROR_CURRENT_DIRECTORY"); break;
        case    17 :  sTempString   = _T("The system cannot move the file to a different disk drive.  ERROR_NOT_SAME_DEVICE"); break;
        case    18 :  sTempString   = _T("There are no more files.  ERROR_NO_MORE_FILES"); break;
        case    19 :  sTempString   = _T("The media is write protected.  ERROR_WRITE_PROTECT"); break;
        case    20 :  sTempString   = _T("The system cannot find the device specified.  ERROR_BAD_UNIT"); break;
        case    21 :  sTempString   = _T("The device is not ready.  ERROR_NOT_READY"); break;
        case    22 :  sTempString   = _T("The device does not recognize the command.  ERROR_BAD_COMMAND"); break;
        case    23 :  sTempString   = _T("Data error (cyclic redundancy check).  ERROR_CRC"); break;
        case    24 :  sTempString   = _T("The program issued a command but the command length is incorrect.  ERROR_BAD_LENGTH"); break;
        case    25 :  sTempString   = _T("The drive cannot locate a specific area or track on the disk.  ERROR_SEEK"); break;
        case    26 :  sTempString   = _T("The specified disk or diskette cannot be accessed.  ERROR_NOT_DOS_DISK"); break;
        case    27 :  sTempString   = _T("The drive cannot find the sector requested.  ERROR_SECTOR_NOT_FOUND"); break;
        case    28 :  sTempString   = _T("The printer is out of paper.  ERROR_OUT_OF_PAPER"); break;
        case    29 :  sTempString   = _T("The system cannot write to the specified device.  ERROR_WRITE_FAULT"); break;
        case    30 :  sTempString   = _T("The system cannot read from the specified device.  ERROR_READ_FAULT"); break;
        case    31 :  sTempString   = _T("A device attached to the system is not functioning.  ERROR_GEN_FAILURE"); break;
        case    32 :  sTempString   = _T("The process cannot access the file because it is being used by another process.  ERROR_SHARING_VIOLATION"); break;
        case    33 :  sTempString   = _T("The process cannot access the file because another process has locked a portion of the file.  ERROR_LOCK_VIOLATION"); break;
        case    34 :  sTempString   = _T("The wrong diskette is in the drive. Insert %%2 (Volume Serial Number: %%3) into drive %%1.  ERROR_WRONG_DISK"); break;
        case    36 :  sTempString   = _T("Too many files opened for sharing.  ERROR_SHARING_BUFFER_EXCEEDED"); break;
        case    38 :  sTempString   = _T("Reached the end of the file.  ERROR_HANDLE_EOF"); break;
        case    39 :  sTempString   = _T("The disk is full.  ERROR_HANDLE_DISK_FULL"); break;
        case    50 :  sTempString   = _T("The network request is not supported.  ERROR_NOT_SUPPORTED"); break;
        case    51 :  sTempString   = _T("The remote computer is not available.  ERROR_REM_NOT_LIST"); break;
        case    52 :  sTempString   = _T("A duplicate name exists on the network.  ERROR_DUP_NAME"); break;
        case    53 :  sTempString   = _T("The network path was not found.  ERROR_BAD_NETPATH"); break;
        case    54 :  sTempString   = _T("The network is busy.  ERROR_NETWORK_BUSY"); break;
        case    55 :  sTempString   = _T("The specified network resource or device is no longer available.  ERROR_DEV_NOT_EXIST"); break;
        case    56 :  sTempString   = _T("The network BIOS command limit has been reached.  ERROR_TOO_MANY_CMDS"); break;
        case    57 :  sTempString   = _T("A network adapter hardware error occurred.  ERROR_ADAP_HDW_ERR"); break;
        case    58 :  sTempString   = _T("The specified server cannot perform the requested operation.  ERROR_BAD_NET_RESP"); break;
        case    59 :  sTempString   = _T("An unexpected network error occurred.  ERROR_UNEXP_NET_ERR"); break;
        case    60 :  sTempString   = _T("The remote adapter is not compatible.  ERROR_BAD_REM_ADAP"); break;
        case    61 :  sTempString   = _T("The printer queue is full.  ERROR_PRINTQ_FULL"); break;
        case    62 :  sTempString   = _T("Space to store the file waiting to be printed is not available on the server.  ERROR_NO_SPOOL_SPACE"); break;
        case    63 :  sTempString   = _T("Your file waiting to be printed was deleted.  ERROR_PRINT_CANCELLED"); break;
        case    64 :  sTempString   = _T("The specified network name is no longer available.  ERROR_NETNAME_DELETED"); break;
        case    65 :  sTempString   = _T("Network access is denied.  ERROR_NETWORK_ACCESS_DENIED"); break;
        case    66 :  sTempString   = _T("The network resource type is not correct.  ERROR_BAD_DEV_TYPE"); break;
        case    67 :  sTempString   = _T("The network name cannot be found.  ERROR_BAD_NET_NAME"); break;
        case    68 :  sTempString   = _T("The name limit for the local computer network adapter card was exceeded.  ERROR_TOO_MANY_NAMES"); break;
        case    69 :  sTempString   = _T("The network BIOS session limit was exceeded.  ERROR_TOO_MANY_SESS"); break;
        case    70 :  sTempString   = _T("The remote server has been paused or is in the process of being started.  ERROR_SHARING_PAUSED"); break;
        case    71 :  sTempString   = _T("No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.  ERROR_REQ_NOT_ACCEP"); break;
        case    72 :  sTempString   = _T("The specified printer or disk device has been paused.  ERROR_REDIR_PAUSED"); break;
        case    80 :  sTempString   = _T("The file exists.  ERROR_FILE_EXISTS"); break;
        case    82 :  sTempString   = _T("The directory or file cannot be created.  ERROR_CANNOT_MAKE"); break;
        case    83 :  sTempString   = _T("Fail on INT 24.  ERROR_FAIL_I24"); break;
        case    84 :  sTempString   = _T("Storage to process this request is not available.  ERROR_OUT_OF_STRUCTURES"); break;
        case    85 :  sTempString   = _T("The local device name is already in use.  ERROR_ALREADY_ASSIGNED"); break;
        case    86 :  sTempString   = _T("The specified network password is not correct.  ERROR_INVALID_PASSWORD"); break;
        case    87 :  sTempString   = _T("The parameter is incorrect.  ERROR_INVALID_PARAMETER"); break;
        case    88 :  sTempString   = _T("A write fault occurred on the network.  ERROR_NET_WRITE_FAULT"); break;
        case    89 :  sTempString   = _T("The system cannot start another process at this time.  ERROR_NO_PROC_SLOTS"); break;
        case   100 :  sTempString   = _T("Cannot create another system semaphore.  ERROR_TOO_MANY_SEMAPHORES"); break;
        case   101 :  sTempString   = _T("The exclusive semaphore is owned by another process.  ERROR_EXCL_SEM_ALREADY_OWNED"); break;
        case   102 :  sTempString   = _T("The semaphore is set and cannot be closed.  ERROR_SEM_IS_SET"); break;
        case   103 :  sTempString   = _T("The semaphore cannot be set again.  ERROR_TOO_MANY_SEM_REQUESTS"); break;
        case   104 :  sTempString   = _T("Cannot request exclusive semaphores at interrupt time.  ERROR_INVALID_AT_INTERRUPT_TIME"); break;
        case   105 :  sTempString   = _T("The previous ownership of this semaphore has ended.  ERROR_SEM_OWNER_DIED"); break;
        case   106 :  sTempString   = _T("Insert the diskette for drive %%1.  ERROR_SEM_USER_LIMIT"); break;
        case   107 :  sTempString   = _T("The program stopped because an alternate diskette was not inserted.  ERROR_DISK_CHANGE"); break;
        case   108 :  sTempString   = _T("The disk is in use or locked by another process.  ERROR_DRIVE_LOCKED"); break;
        case   109 :  sTempString   = _T("The pipe has been ended.  ERROR_BROKEN_PIPE"); break;
        case   110 :  sTempString   = _T("The system cannot open the device or file specified.  ERROR_OPEN_FAILED"); break;
        case   111 :  sTempString   = _T("The file name is too long.  ERROR_BUFFER_OVERFLOW"); break;
        case   112 :  sTempString   = _T("There is not enough space on the disk.  ERROR_DISK_FULL"); break;
        case   113 :  sTempString   = _T("No more internal file identifiers available.  ERROR_NO_MORE_SEARCH_HANDLES"); break;
        case   114 :  sTempString   = _T("The target internal file identifier is incorrect.  ERROR_INVALID_TARGET_HANDLE"); break;
        case   117 :  sTempString   = _T("The IOCTL call made by the application program is not correct.  ERROR_INVALID_CATEGORY"); break;
        case   118 :  sTempString   = _T("The verify-on-write switch parameter value is not correct.  ERROR_INVALID_VERIFY_SWITCH"); break;
        case   119 :  sTempString   = _T("The system does not support the command requested.  ERROR_BAD_DRIVER_LEVEL"); break;
        case   120 :  sTempString   = _T("This function is not supported on this system.  ERROR_CALL_NOT_IMPLEMENTED"); break;
        case   121 :  sTempString   = _T("The semaphore timeout period has expired.  ERROR_SEM_TIMEOUT"); break;
        case   122 :  sTempString   = _T("The data area passed to a system call is too small.  ERROR_INSUFFICIENT_BUFFER"); break;
        case   123 :  sTempString   = _T("The filename, directory name, or volume label syntax is incorrect.  ERROR_INVALID_NAME"); break;
        case   124 :  sTempString   = _T("The system call level is not correct.  ERROR_INVALID_LEVEL"); break;
        case   125 :  sTempString   = _T("The disk has no volume label.  ERROR_NO_VOLUME_LABEL"); break;
        case   126 :  sTempString   = _T("The specified module could not be found.  ERROR_MOD_NOT_FOUND"); break;
        case   127 :  sTempString   = _T("The specified procedure could not be found.  ERROR_PROC_NOT_FOUND"); break;
        case   128 :  sTempString   = _T("There are no child processes to wait for.  ERROR_WAIT_NO_CHILDREN"); break;
        case   129 :  sTempString   = _T("The %%1 application cannot be run in Win32 mode.  ERROR_CHILD_NOT_COMPLETE"); break;
        case   130 :  sTempString   = _T("Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.  ERROR_DIRECT_ACCESS_HANDLE"); break;
        case   131 :  sTempString   = _T("An attempt was made to move the file pointer before the beginning of the file.  ERROR_NEGATIVE_SEEK"); break;
        case   132 :  sTempString   = _T("The file pointer cannot be set on the specified device or file.  ERROR_SEEK_ON_DEVICE"); break;
        case   133 :  sTempString   = _T("A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.  ERROR_IS_JOIN_TARGET"); break;
        case   134 :  sTempString   = _T("An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.  ERROR_IS_JOINED"); break;
        case   135 :  sTempString   = _T("An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.  ERROR_IS_SUBSTED"); break;
        case   136 :  sTempString   = _T("The system tried to delete the JOIN of a drive that is not joined.  ERROR_NOT_JOINED"); break;
        case   137 :  sTempString   = _T("The system tried to delete the substitution of a drive that is not substituted.  ERROR_NOT_SUBSTED"); break;
        case   138 :  sTempString   = _T("The system tried to join a drive to a directory on a joined drive.  ERROR_JOIN_TO_JOIN"); break;
        case   139 :  sTempString   = _T("The system tried to substitute a drive to a directory on a substituted drive.  ERROR_SUBST_TO_SUBST"); break;
        case   140 :  sTempString   = _T("The system tried to join a drive to a directory on a substituted drive.  ERROR_JOIN_TO_SUBST"); break;
        case   141 :  sTempString   = _T("The system tried to SUBST a drive to a directory on a joined drive.  ERROR_SUBST_TO_JOIN"); break;
        case   142 :  sTempString   = _T("The system cannot perform a JOIN or SUBST at this time.  ERROR_BUSY_DRIVE"); break;
        case   143 :  sTempString   = _T("The system cannot join or substitute a drive to or for a directory on the same drive.  ERROR_SAME_DRIVE"); break;
        case   144 :  sTempString   = _T("The directory is not a subdirectory of the root directory.  ERROR_DIR_NOT_ROOT"); break;
        case   145 :  sTempString   = _T("The directory is not empty.  ERROR_DIR_NOT_EMPTY"); break;
        case   146 :  sTempString   = _T("The path specified is being used in a substitute.  ERROR_IS_SUBST_PATH"); break;
        case   147 :  sTempString   = _T("Not enough resources are available to process this command.  ERROR_IS_JOIN_PATH"); break;
        case   148 :  sTempString   = _T("The path specified cannot be used at this time.  ERROR_PATH_BUSY"); break;
        case   149 :  sTempString   = _T("An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.  ERROR_IS_SUBST_TARGET"); break;
        case   150 :  sTempString   = _T("System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.  ERROR_SYSTEM_TRACE"); break;
        case   151 :  sTempString   = _T("The number of specified semaphore events for DosMuxSemWait is not correct.  ERROR_INVALID_EVENT_COUNT"); break;
        case   152 :  sTempString   = _T("DosMuxSemWait did not execute; too many semaphores are already set.  ERROR_TOO_MANY_MUXWAITERS"); break;
        case   153 :  sTempString   = _T("The DosMuxSemWait list is not correct.  ERROR_INVALID_LIST_FORMAT"); break;
        case   154 :  sTempString   = _T("The volume label you entered exceeds the label character limit of the target file system.  ERROR_LABEL_TOO_LONG"); break;
        case   155 :  sTempString   = _T("Cannot create another thread.  ERROR_TOO_MANY_TCBS"); break;
        case   156 :  sTempString   = _T("The recipient process has refused the signal.  ERROR_SIGNAL_REFUSED"); break;
        case   157 :  sTempString   = _T("The segment is already discarded and cannot be locked.  ERROR_DISCARDED"); break;
        case   158 :  sTempString   = _T("The segment is already unlocked.  ERROR_NOT_LOCKED"); break;
        case   159 :  sTempString   = _T("The address for the thread ID is not correct.  ERROR_BAD_THREADID_ADDR"); break;
        case   160 :  sTempString   = _T("The argument string passed to DosExecPgm is not correct.  ERROR_BAD_ARGUMENTS"); break;
        case   161 :  sTempString   = _T("The specified path is invalid.  ERROR_BAD_PATHNAME"); break;
        case   162 :  sTempString   = _T("A signal is already pending.  ERROR_SIGNAL_PENDING"); break;
        case   164 :  sTempString   = _T("No more threads can be created in the system.  ERROR_MAX_THRDS_REACHED"); break;
        case   167 :  sTempString   = _T("Unable to lock a region of a file.  ERROR_LOCK_FAILED"); break;
        case   170 :  sTempString   = _T("The requested resource is in use.  ERROR_BUSY"); break;
        case   173 :  sTempString   = _T("A lock request was not outstanding for the supplied cancel region.  ERROR_CANCEL_VIOLATION"); break;
        case   174 :  sTempString   = _T("The file system does not support atomic changes to the lock type.  ERROR_ATOMIC_LOCKS_NOT_SUPPORTED"); break;
        case   180 :  sTempString   = _T("The system detected a segment number that was not correct.  ERROR_INVALID_SEGMENT_NUMBER"); break;
        case   182 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INVALID_ORDINAL"); break;
        case   183 :  sTempString   = _T("Cannot create a file when that file already exists.  ERROR_ALREADY_EXISTS"); break;
        case   186 :  sTempString   = _T("The flag passed is not correct.  ERROR_INVALID_FLAG_NUMBER"); break;
        case   187 :  sTempString   = _T("The specified system semaphore name was not found.  ERROR_SEM_NOT_FOUND"); break;
        case   188 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INVALID_STARTING_CODESEG"); break;
        case   189 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INVALID_STACKSEG"); break;
        case   190 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INVALID_MODULETYPE"); break;
        case   191 :  sTempString   = _T("Cannot run %%1 in Win32 mode.  ERROR_INVALID_EXE_SIGNATURE"); break;
        case   192 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_EXE_MARKED_INVALID"); break;
        case   193 :  sTempString   = _T("%%1 is not a valid Win32 application.  ERROR_BAD_EXE_FORMAT"); break;
        case   194 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_ITERATED_DATA_EXCEEDS_64k"); break;
        case   195 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INVALID_MINALLOCSIZE"); break;
        case   196 :  sTempString   = _T("The operating system cannot run this application program.  ERROR_DYNLINK_FROM_INVALID_RING"); break;
        case   197 :  sTempString   = _T("The operating system is not presently configured to run this application.  ERROR_IOPL_NOT_ENABLED"); break;
        case   198 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INVALID_SEGDPL"); break;
        case   199 :  sTempString   = _T("The operating system cannot run this application program.  ERROR_AUTODATASEG_EXCEEDS_64k"); break;
        case   200 :  sTempString   = _T("The code segment cannot be greater than or equal to 64K.  ERROR_RING2SEG_MUST_BE_MOVABLE"); break;
        case   201 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_RELOC_CHAIN_XEEDS_SEGLIM"); break;
        case   202 :  sTempString   = _T("The operating system cannot run %%1.  ERROR_INFLOOP_IN_RELOC_CHAIN"); break;
        case   203 :  sTempString   = _T("The system could not find the environment option that was entered.  ERROR_ENVVAR_NOT_FOUND"); break;
        case   205 :  sTempString   = _T("No process in the command subtree has a signal handler.  ERROR_NO_SIGNAL_SENT"); break;
        case   206 :  sTempString   = _T("The filename or extension is too long.  ERROR_FILENAME_EXCED_RANGE"); break;
        case   207 :  sTempString   = _T("The ring 2 stack is in use.  ERROR_RING2_STACK_IN_USE"); break;
        case   208 :  sTempString   = _T("The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.  ERROR_META_EXPANSION_TOO_LONG"); break;
        case   209 :  sTempString   = _T("The signal being posted is not correct.  ERROR_INVALID_SIGNAL_NUMBER"); break;
        case   210 :  sTempString   = _T("The signal handler cannot be set.  ERROR_THREAD_1_INACTIVE"); break;
        case   212 :  sTempString   = _T("The segment is locked and cannot be reallocated.  ERROR_LOCKED"); break;
        case   214 :  sTempString   = _T("Too many dynamic-link modules are attached to this program or dynamic-link module.  ERROR_TOO_MANY_MODULES"); break;
        case   215 :  sTempString   = _T("Cannot nest calls to LoadModule.  ERROR_NESTING_NOT_ALLOWED"); break;
        case   216 :  sTempString   = _T("The image file %%1 is valid, but is for a machine type other than the current machine.  ERROR_EXE_MACHINE_TYPE_MISMATCH"); break;
        case   230 :  sTempString   = _T("The pipe state is invalid.  ERROR_BAD_PIPE"); break;
        case   231 :  sTempString   = _T("All pipe instances are busy.  ERROR_PIPE_BUSY"); break;
        case   232 :  sTempString   = _T("The pipe is being closed.  ERROR_NO_DATA"); break;
        case   233 :  sTempString   = _T("No process is on the other end of the pipe.  ERROR_PIPE_NOT_CONNECTED"); break;
        case   234 :  sTempString   = _T("More data is available.  ERROR_MORE_DATA"); break;
        case   240 :  sTempString   = _T("The session was canceled.  ERROR_VC_DISCONNECTED"); break;
        case   254 :  sTempString   = _T("The specified extended attribute name was invalid.  ERROR_INVALID_EA_NAME"); break;
        case   255 :  sTempString   = _T("The extended attributes are inconsistent.  ERROR_EA_LIST_INCONSISTENT"); break;
        case   258 :  sTempString   = _T("The wait operation timed out.  WAIT_TIMEOUT"); break;
        case   259 :  sTempString   = _T("No more data is available.  ERROR_NO_MORE_ITEMS"); break;
        case   266 :  sTempString   = _T("The copy functions cannot be used.  ERROR_CANNOT_COPY"); break;
        case   267 :  sTempString   = _T("The directory name is invalid.  ERROR_DIRECTORY"); break;
        case   275 :  sTempString   = _T("The extended attributes did not fit in the buffer.  ERROR_EAS_DIDNT_FIT"); break;
        case   276 :  sTempString   = _T("The extended attribute file on the mounted file system is corrupt.  ERROR_EA_FILE_CORRUPT"); break;
        case   277 :  sTempString   = _T("The extended attribute table file is full.  ERROR_EA_TABLE_FULL"); break;
        case   278 :  sTempString   = _T("The specified extended attribute handle is invalid.  ERROR_INVALID_EA_HANDLE"); break;
        case   282 :  sTempString   = _T("The mounted file system does not support extended attributes.  ERROR_EAS_NOT_SUPPORTED"); break;
        case   288 :  sTempString   = _T("Attempt to release mutex not owned by caller.  ERROR_NOT_OWNER"); break;
        case   298 :  sTempString   = _T("Too many posts were made to a semaphore.  ERROR_TOO_MANY_POSTS"); break;
        case   299 :  sTempString   = _T("Only part of a ReadProcessMemory or WriteProcessMemory request was completed.  ERROR_PARTIAL_COPY"); break;
        case   300 :  sTempString   = _T("The oplock request is denied.  ERROR_OPLOCK_NOT_GRANTED"); break;
        case   301 :  sTempString   = _T("An invalid oplock acknowledgment was received by the system.  ERROR_INVALID_OPLOCK_PROTOCOL"); break;
        case   317 :  sTempString   = _T("The system cannot find message text for message number 0x%%1 in the message file for %%2.  ERROR_MR_MID_NOT_FOUND"); break;
        case   487 :  sTempString   = _T("Attempt to access invalid address.  ERROR_INVALID_ADDRESS"); break;
        case   534 :  sTempString   = _T("Arithmetic result exceeded 32 bits.  ERROR_ARITHMETIC_OVERFLOW"); break;
        case   535 :  sTempString   = _T("There is a process on other end of the pipe.  ERROR_PIPE_CONNECTED"); break;
        case   536 :  sTempString   = _T("Waiting for a process to open the other end of the pipe.  ERROR_PIPE_LISTENING"); break;
        case   994 :  sTempString   = _T("Access to the extended attribute was denied.  ERROR_EA_ACCESS_DENIED"); break;
        case   995 :  sTempString   = _T("The I/O operation has been aborted because of either a thread exit or an application request.  ERROR_OPERATION_ABORTED"); break;
        case   996 :  sTempString   = _T("Overlapped I/O event is not in a signaled state.  ERROR_IO_INCOMPLETE"); break;
        case   997 :  sTempString   = _T("Overlapped I/O operation is in progress.  ERROR_IO_PENDING"); break;
        case   998 :  sTempString   = _T("Invalid access to memory location.  ERROR_NOACCESS"); break;
        case   999 :  sTempString   = _T("Error performing inpage operation.  ERROR_SWAPERROR"); break;
        case  1001 :  sTempString   = _T("Recursion too deep; the stack overflowed.  ERROR_STACK_OVERFLOW"); break;
        case  1002 :  sTempString   = _T("The window cannot act on the sent message.  ERROR_INVALID_MESSAGE"); break;
        case  1003 :  sTempString   = _T("Cannot complete this function.  ERROR_CAN_NOT_COMPLETE"); break;
        case  1004 :  sTempString   = _T("Invalid flags.  ERROR_INVALID_FLAGS"); break;
        case  1005 :  sTempString   = _T("The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted.  ERROR_UNRECOGNIZED_VOLUME"); break;
        case  1006 :  sTempString   = _T("The volume for a file has been externally altered so that the opened file is no longer valid.  ERROR_FILE_INVALID"); break;
        case  1007 :  sTempString   = _T("The requested operation cannot be performed in full-screen mode.  ERROR_FULLSCREEN_MODE"); break;
        case  1008 :  sTempString   = _T("An attempt was made to reference a token that does not exist.  ERROR_NO_TOKEN"); break;
        case  1009 :  sTempString   = _T("The configuration registry database is corrupt.  ERROR_BADDB"); break;
        case  1010 :  sTempString   = _T("The configuration registry key is invalid.  ERROR_BADKEY"); break;
        case  1011 :  sTempString   = _T("The configuration registry key could not be opened.  ERROR_CANTOPEN"); break;
        case  1012 :  sTempString   = _T("The configuration registry key could not be read.  ERROR_CANTREAD"); break;
        case  1013 :  sTempString   = _T("The configuration registry key could not be written.  ERROR_CANTWRITE"); break;
        case  1014 :  sTempString   = _T("One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.  ERROR_REGISTRY_RECOVERED"); break;
        case  1015 :  sTempString   = _T("The registry is corrupted. The structure of one of the files containing registry data is corrupted, or the system's memory image of the file is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.  ERROR_REGISTRY_CORRUPT"); break;
        case  1016 :  sTempString   = _T("An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.  ERROR_REGISTRY_IO_FAILED"); break;
        case  1017 :  sTempString   = _T("The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.  ERROR_NOT_REGISTRY_FILE"); break;
        case  1018 :  sTempString   = _T("Illegal operation attempted on a registry key that has been marked for deletion.  ERROR_KEY_DELETED"); break;
        case  1019 :  sTempString   = _T("System could not allocate the required space in a registry log.  ERROR_NO_LOG_SPACE"); break;
        case  1020 :  sTempString   = _T("Cannot create a symbolic link in a registry key that already has subkeys or values.  ERROR_KEY_HAS_CHILDREN"); break;
        case  1021 :  sTempString   = _T("Cannot create a stable subkey under a volatile parent key.  ERROR_CHILD_MUST_BE_VOLATILE"); break;
        case  1022 :  sTempString   = _T("A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.  ERROR_NOTIFY_ENUM_DIR"); break;
        case  1051 :  sTempString   = _T("A stop control has been sent to a service that other running services are dependent on.  ERROR_DEPENDENT_SERVICES_RUNNING"); break;
        case  1052 :  sTempString   = _T("The requested control is not valid for this service.  ERROR_INVALID_SERVICE_CONTROL"); break;
        case  1053 :  sTempString   = _T("The service did not respond to the start or control request in a timely fashion.  ERROR_SERVICE_REQUEST_TIMEOUT"); break;
        case  1054 :  sTempString   = _T("A thread could not be created for the service.  ERROR_SERVICE_NO_THREAD"); break;
        case  1055 :  sTempString   = _T("The service database is locked.  ERROR_SERVICE_DATABASE_LOCKED"); break;
        case  1056 :  sTempString   = _T("An instance of the service is already running.  ERROR_SERVICE_ALREADY_RUNNING"); break;
        case  1057 :  sTempString   = _T("The account name is invalid or does not exist, or the password is invalid for the account name specified.  ERROR_INVALID_SERVICE_ACCOUNT"); break;
        case  1058 :  sTempString   = _T("The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.  ERROR_SERVICE_DISABLED"); break;
        case  1059 :  sTempString   = _T("Circular service dependency was specified.  ERROR_CIRCULAR_DEPENDENCY"); break;
        case  1060 :  sTempString   = _T("The specified service does not exist as an installed service.  ERROR_SERVICE_DOES_NOT_EXIST"); break;
        case  1061 :  sTempString   = _T("The service cannot accept control messages at this time.  ERROR_SERVICE_CANNOT_ACCEPT_CTRL"); break;
        case  1062 :  sTempString   = _T("The service has not been started.  ERROR_SERVICE_NOT_ACTIVE"); break;
        case  1063 :  sTempString   = _T("The service process could not connect to the service controller.  ERROR_FAILED_SERVICE_CONTROLLER_CONNECT"); break;
        case  1064 :  sTempString   = _T("An exception occurred in the service when handling the control request.  ERROR_EXCEPTION_IN_SERVICE"); break;
        case  1065 :  sTempString   = _T("The database specified does not exist.  ERROR_DATABASE_DOES_NOT_EXIST"); break;
        case  1066 :  sTempString   = _T("The service has returned a service-specific error code.  ERROR_SERVICE_SPECIFIC_ERROR"); break;
        case  1067 :  sTempString   = _T("The process terminated unexpectedly.  ERROR_PROCESS_ABORTED"); break;
        case  1068 :  sTempString   = _T("The dependency service or group failed to start.  ERROR_SERVICE_DEPENDENCY_FAIL"); break;
        case  1069 :  sTempString   = _T("The service did not start due to a logon failure.  ERROR_SERVICE_LOGON_FAILED"); break;
        case  1070 :  sTempString   = _T("After starting, the service hung in a start-pending state.  ERROR_SERVICE_START_HANG"); break;
        case  1071 :  sTempString   = _T("The specified service database lock is invalid.  ERROR_INVALID_SERVICE_LOCK"); break;
        case  1072 :  sTempString   = _T("The specified service has been marked for deletion.  ERROR_SERVICE_MARKED_FOR_DELETE"); break;
        case  1073 :  sTempString   = _T("The specified service already exists.  ERROR_SERVICE_EXISTS"); break;
        case  1074 :  sTempString   = _T("The system is currently running with the last-known-good configuration.  ERROR_ALREADY_RUNNING_LKG"); break;
        case  1075 :  sTempString   = _T("The dependency service does not exist or has been marked for deletion.  ERROR_SERVICE_DEPENDENCY_DELETED"); break;
        case  1076 :  sTempString   = _T("The current boot has already been accepted for use as the last-known-good control set.  ERROR_BOOT_ALREADY_ACCEPTED"); break;
        case  1077 :  sTempString   = _T("No attempts to start the service have been made since the last boot.  ERROR_SERVICE_NEVER_STARTED"); break;
        case  1078 :  sTempString   = _T("The name is already in use as either a service name or a service display name.  ERROR_DUPLICATE_SERVICE_NAME"); break;
        case  1079 :  sTempString   = _T("The account specified for this service is different from the account specified for other services running in the same process.  ERROR_DIFFERENT_SERVICE_ACCOUNT"); break;
        case  1080 :  sTempString   = _T("Failure actions can only be set for Win32 services, not for drivers.  ERROR_CANNOT_DETECT_DRIVER_FAILURE"); break;
        case  1081 :  sTempString   = _T("This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.  ERROR_CANNOT_DETECT_PROCESS_ABORT"); break;
        case  1082 :  sTempString   = _T("No recovery program has been configured for this service.  ERROR_NO_RECOVERY_PROGRAM"); break;
        case  1083 :  sTempString   = _T("The executable program that this service is configured to run in does not implement the service.  ERROR_SERVICE_NOT_IN_EXE"); break;
        case  1100 :  sTempString   = _T("The physical end of the tape has been reached.  ERROR_END_OF_MEDIA"); break;
        case  1101 :  sTempString   = _T("A tape access reached a filemark.  ERROR_FILEMARK_DETECTED"); break;
        case  1102 :  sTempString   = _T("The beginning of the tape or a partition was encountered.  ERROR_BEGINNING_OF_MEDIA"); break;
        case  1103 :  sTempString   = _T("A tape access reached the end of a set of files.  ERROR_SETMARK_DETECTED"); break;
        case  1104 :  sTempString   = _T("No more data is on the tape.  ERROR_NO_DATA_DETECTED"); break;
        case  1105 :  sTempString   = _T("Tape could not be partitioned.  ERROR_PARTITION_FAILURE"); break;
        case  1106 :  sTempString   = _T("When accessing a new tape of a multivolume partition, the current block size is incorrect.  ERROR_INVALID_BLOCK_LENGTH"); break;
        case  1107 :  sTempString   = _T("Tape partition information could not be found when loading a tape.  ERROR_DEVICE_NOT_PARTITIONED"); break;
        case  1108 :  sTempString   = _T("Unable to lock the media eject mechanism.  ERROR_UNABLE_TO_LOCK_MEDIA"); break;
        case  1109 :  sTempString   = _T("Unable to unload the media.  ERROR_UNABLE_TO_UNLOAD_MEDIA"); break;
        case  1110 :  sTempString   = _T("The media in the drive may have changed.  ERROR_MEDIA_CHANGED"); break;
        case  1111 :  sTempString   = _T("The I/O bus was reset.  ERROR_BUS_RESET"); break;
        case  1112 :  sTempString   = _T("No media in drive.  ERROR_NO_MEDIA_IN_DRIVE"); break;
        case  1113 :  sTempString   = _T("No mapping for the Unicode character exists in the target multi-byte code page.  ERROR_NO_UNICODE_TRANSLATION"); break;
        case  1114 :  sTempString   = _T("A dynamic link library (DLL) initialization routine failed.  ERROR_DLL_INIT_FAILED"); break;
        case  1115 :  sTempString   = _T("A system shutdown is in progress.  ERROR_SHUTDOWN_IN_PROGRESS"); break;
        case  1116 :  sTempString   = _T("Unable to abort the system shutdown because no shutdown was in progress.  ERROR_NO_SHUTDOWN_IN_PROGRESS"); break;
        case  1117 :  sTempString   = _T("The request could not be performed because of an I/O device error.  ERROR_IO_DEVICE"); break;
        case  1118 :  sTempString   = _T("No serial device was successfully initialized. The serial driver will unload.  ERROR_SERIAL_NO_DEVICE"); break;
        case  1119 :  sTempString   = _T("Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.  ERROR_IRQ_BUSY"); break;
        case  1120 :  sTempString   = _T("A serial I/O operation was completed by another write to the serial port. (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)  ERROR_MORE_WRITES"); break;
        case  1121 :  sTempString   = _T("A serial I/O operation completed because the timeout period expired. (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)  ERROR_COUNTER_TIMEOUT"); break;
        case  1122 :  sTempString   = _T("No ID address mark was found on the floppy disk.  ERROR_FLOPPY_ID_MARK_NOT_FOUND"); break;
        case  1123 :  sTempString   = _T("Mismatch between the floppy disk sector ID field and the floppy disk controller track address.  ERROR_FLOPPY_WRONG_CYLINDER"); break;
        case  1124 :  sTempString   = _T("The floppy disk controller reported an error that is not recognized by the floppy disk driver.  ERROR_FLOPPY_UNKNOWN_ERROR"); break;
        case  1125 :  sTempString   = _T("The floppy disk controller returned inconsistent results in its registers.  ERROR_FLOPPY_BAD_REGISTERS"); break;
        case  1126 :  sTempString   = _T("While accessing the hard disk, a recalibrate operation failed, even after retries.  ERROR_DISK_RECALIBRATE_FAILED"); break;
        case  1127 :  sTempString   = _T("While accessing the hard disk, a disk operation failed even after retries.  ERROR_DISK_OPERATION_FAILED"); break;
        case  1128 :  sTempString   = _T("While accessing the hard disk, a disk controller reset was needed, but even that failed.  ERROR_DISK_RESET_FAILED"); break;
        case  1129 :  sTempString   = _T("Physical end of tape encountered.  ERROR_EOM_OVERFLOW"); break;
        case  1130 :  sTempString   = _T("Not enough server storage is available to process this command.  ERROR_NOT_ENOUGH_SERVER_MEMORY"); break;
        case  1131 :  sTempString   = _T("A potential deadlock condition has been detected.  ERROR_POSSIBLE_DEADLOCK"); break;
        case  1132 :  sTempString   = _T("The base address or the file offset specified does not have the proper alignment.  ERROR_MAPPED_ALIGNMENT"); break;
        case  1140 :  sTempString   = _T("An attempt to change the system power state was vetoed by another application or driver.  ERROR_SET_POWER_STATE_VETOED"); break;
        case  1141 :  sTempString   = _T("The system BIOS failed an attempt to change the system power state.  ERROR_SET_POWER_STATE_FAILED"); break;
        case  1142 :  sTempString   = _T("An attempt was made to create more links on a file than the file system supports.  ERROR_TOO_MANY_LINKS"); break;
        case  1150 :  sTempString   = _T("The specified program requires a newer version of Windows.  ERROR_OLD_WIN_VERSION"); break;
        case  1151 :  sTempString   = _T("The specified program is not a Windows or MS-DOS program.  ERROR_APP_WRONG_OS"); break;
        case  1152 :  sTempString   = _T("Cannot start more than one instance of the specified program.  ERROR_SINGLE_INSTANCE_APP"); break;
        case  1153 :  sTempString   = _T("The specified program was written for an earlier version of Windows.  ERROR_RMODE_APP"); break;
        case  1154 :  sTempString   = _T("One of the library files needed to run this application is damaged.  ERROR_INVALID_DLL"); break;
        case  1155 :  sTempString   = _T("No application is associated with the specified file for this operation.  ERROR_NO_ASSOCIATION"); break;
        case  1156 :  sTempString   = _T("An error occurred in sending the command to the application.  ERROR_DDE_FAIL"); break;
        case  1157 :  sTempString   = _T("One of the library files needed to run this application cannot be found.  ERROR_DLL_NOT_FOUND"); break;
        case  1158 :  sTempString   = _T("The current process has used all of its system allowance of handles for Window Manager objects.  ERROR_NO_MORE_USER_HANDLES"); break;
        case  1159 :  sTempString   = _T("The message can be used only with synchronous operations.  ERROR_MESSAGE_SYNC_ONLY"); break;
        case  1160 :  sTempString   = _T("The indicated source element has no media.  ERROR_SOURCE_ELEMENT_EMPTY"); break;
        case  1161 :  sTempString   = _T("The indicated destination element already contains media.  ERROR_DESTINATION_ELEMENT_FULL"); break;
        case  1162 :  sTempString   = _T("The indicated element does not exist.  ERROR_ILLEGAL_ELEMENT_ADDRESS"); break;
        case  1163 :  sTempString   = _T("The indicated element is part of a magazine that is not present.  ERROR_MAGAZINE_NOT_PRESENT"); break;
        case  1164 :  sTempString   = _T("The indicated device requires reinitialization due to hardware errors.  ERROR_DEVICE_REINITIALIZATION_NEEDED"); break;
        case  1165 :  sTempString   = _T("The device has indicated that cleaning is required before further operations are attempted.  ERROR_DEVICE_REQUIRES_CLEANING"); break;
        case  1166 :  sTempString   = _T("The device has indicated that its door is open.  ERROR_DEVICE_DOOR_OPEN"); break;
        case  1167 :  sTempString   = _T("The device is not connected.  ERROR_DEVICE_NOT_CONNECTED"); break;
        case  1168 :  sTempString   = _T("Element not found.  ERROR_NOT_FOUND"); break;
        case  1169 :  sTempString   = _T("There was no match for the specified key in the index.  ERROR_NO_MATCH"); break;
        case  1170 :  sTempString   = _T("The property set specified does not exist on the object.  ERROR_SET_NOT_FOUND"); break;
        case  1171 :  sTempString   = _T("The point passed to GetMouseMovePointsEx is not in the buffer.  ERROR_POINT_NOT_FOUND"); break;
        case  1172 :  sTempString   = _T("The tracking (workstation) service is not running.  ERROR_NO_TRACKING_SERVICE"); break;
        case  1173 :  sTempString   = _T("The Volume ID could not be found.  ERROR_NO_VOLUME_ID"); break;
        case  1175 :  sTempString   = _T("Unable to remove the file to be replaced.  ERROR_UNABLE_TO_REMOVE_REPLACED"); break;
        case  1176 :  sTempString   = _T("Unable to move the replacement file to the file to be replaced. The file to be replaced has retained its original name.  ERROR_UNABLE_TO_MOVE_REPLACEMENT"); break;
        case  1177 :  sTempString   = _T("Unable to move the replacement file to the file to be replaced. The file to be replaced has been renamed using the backup name.  ERROR_UNABLE_TO_MOVE_REPLACEMENT_2"); break;
        case  1178 :  sTempString   = _T("The volume change journal is being deleted.  ERROR_JOURNAL_DELETE_IN_PROGRESS"); break;
        case  1179 :  sTempString   = _T("The volume change journal service is not active.  ERROR_JOURNAL_NOT_ACTIVE"); break;
        case  1180 :  sTempString   = _T("A file was found, but it may not be the correct file.  ERROR_POTENTIAL_FILE_FOUND"); break;
        case  1181 :  sTempString   = _T("The journal entry has been deleted from the journal. ERROR_JOURNAL_ENTRY_DELETED"); break;
        case  1200 :  sTempString   = _T("The specified device name is invalid.  ERROR_BAD_DEVICE"); break;
        case  1201 :  sTempString   = _T("The device is not currently connected but it is a remembered connection.  ERROR_CONNECTION_UNAVAIL"); break;
        case  1202 :  sTempString   = _T("An attempt was made to remember a device that had previously been remembered.  ERROR_DEVICE_ALREADY_REMEMBERED"); break;
        case  1203 :  sTempString   = _T("No network provider accepted the given network path.  ERROR_NO_NET_OR_BAD_PATH"); break;
        case  1204 :  sTempString   = _T("The specified network provider name is invalid.  ERROR_BAD_PROVIDER"); break;
        case  1205 :  sTempString   = _T("Unable to open the network connection profile.  ERROR_CANNOT_OPEN_PROFILE"); break;
        case  1206 :  sTempString   = _T("The network connection profile is corrupted.  ERROR_BAD_PROFILE"); break;
        case  1207 :  sTempString   = _T("Cannot enumerate a noncontainer.  ERROR_NOT_CONTAINER"); break;
        case  1208 :  sTempString   = _T("An extended error has occurred.  ERROR_EXTENDED_ERROR"); break;
        case  1209 :  sTempString   = _T("The format of the specified group name is invalid.  ERROR_INVALID_GROUPNAME"); break;
        case  1210 :  sTempString   = _T("The format of the specified computer name is invalid.  ERROR_INVALID_COMPUTERNAME"); break;
        case  1211 :  sTempString   = _T("The format of the specified event name is invalid.  ERROR_INVALID_EVENTNAME"); break;
        case  1212 :  sTempString   = _T("The format of the specified domain name is invalid.  ERROR_INVALID_DOMAINNAME"); break;
        case  1213 :  sTempString   = _T("The format of the specified service name is invalid.  ERROR_INVALID_SERVICENAME"); break;
        case  1214 :  sTempString   = _T("The format of the specified network name is invalid.  ERROR_INVALID_NETNAME"); break;
        case  1215 :  sTempString   = _T("The format of the specified share name is invalid.  ERROR_INVALID_SHARENAME"); break;
        case  1216 :  sTempString   = _T("The format of the specified password is invalid.  ERROR_INVALID_PASSWORDNAME"); break;
        case  1217 :  sTempString   = _T("The format of the specified message name is invalid.  ERROR_INVALID_MESSAGENAME"); break;
        case  1218 :  sTempString   = _T("The format of the specified message destination is invalid.  ERROR_INVALID_MESSAGEDEST"); break;
        case  1219 :  sTempString   = _T("The credentials supplied conflict with an existing set of credentials.  ERROR_SESSION_CREDENTIAL_CONFLICT"); break;
        case  1220 :  sTempString   = _T("An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.  ERROR_REMOTE_SESSION_LIMIT_EXCEEDED"); break;
        case  1221 :  sTempString   = _T("The workgroup or domain name is already in use by another computer on the network.  ERROR_DUP_DOMAINNAME"); break;
        case  1222 :  sTempString   = _T("The network is not present or not started.  ERROR_NO_NETWORK"); break;
        case  1223 :  sTempString   = _T("The operation was canceled by the user.  ERROR_CANCELLED"); break;
        case  1224 :  sTempString   = _T("The requested operation cannot be performed on a file with a user-mapped section open.  ERROR_USER_MAPPED_FILE"); break;
        case  1225 :  sTempString   = _T("The remote system refused the network connection.  ERROR_CONNECTION_REFUSED"); break;
        case  1226 :  sTempString   = _T("The network connection was gracefully closed.  ERROR_GRACEFUL_DISCONNECT"); break;
        case  1227 :  sTempString   = _T("The network transport endpoint already has an address associated with it.  ERROR_ADDRESS_ALREADY_ASSOCIATED"); break;
        case  1228 :  sTempString   = _T("An address has not yet been associated with the network endpoint.  ERROR_ADDRESS_NOT_ASSOCIATED"); break;
        case  1229 :  sTempString   = _T("An operation was attempted on a nonexistent network connection.  ERROR_CONNECTION_INVALID"); break;
        case  1230 :  sTempString   = _T("An invalid operation was attempted on an active network connection.  ERROR_CONNECTION_ACTIVE"); break;
        case  1231 :  sTempString   = _T("The network location cannot be reached. For information about network troubleshooting, see Windows Help.  ERROR_NETWORK_UNREACHABLE"); break;
        case  1232 :  sTempString   = _T("The network location cannot be reached. For information about network troubleshooting, see Windows Help.  ERROR_HOST_UNREACHABLE"); break;
        case  1233 :  sTempString   = _T("The network location cannot be reached. For information about network troubleshooting, see Windows Help.  ERROR_PROTOCOL_UNREACHABLE"); break;
        case  1234 :  sTempString   = _T("No service is operating at the destination network endpoint on the remote system.  ERROR_PORT_UNREACHABLE"); break;
        case  1235 :  sTempString   = _T("The request was aborted.  ERROR_REQUEST_ABORTED"); break;
        case  1236 :  sTempString   = _T("The network connection was aborted by the local system.  ERROR_CONNECTION_ABORTED"); break;
        case  1237 :  sTempString   = _T("The operation could not be completed. A retry should be performed.  ERROR_RETRY"); break;
        case  1238 :  sTempString   = _T("A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.  ERROR_CONNECTION_COUNT_LIMIT"); break;
        case  1239 :  sTempString   = _T("Attempting to log in during an unauthorized time of day for this account.  ERROR_LOGIN_TIME_RESTRICTION"); break;
        case  1240 :  sTempString   = _T("The account is not authorized to log in from this station.  ERROR_LOGIN_WKSTA_RESTRICTION"); break;
        case  1241 :  sTempString   = _T("The network address could not be used for the operation requested.  ERROR_INCORRECT_ADDRESS"); break;
        case  1242 :  sTempString   = _T("The service is already registered.  ERROR_ALREADY_REGISTERED"); break;
        case  1243 :  sTempString   = _T("The specified service does not exist.  ERROR_SERVICE_NOT_FOUND"); break;
        case  1244 :  sTempString   = _T("The operation being requested was not performed because the user has not been authenticated.  ERROR_NOT_AUTHENTICATED"); break;
        case  1245 :  sTempString   = _T("The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.  ERROR_NOT_LOGGED_ON"); break;
        case  1246 :  sTempString   = _T("Continue with work in progress.  ERROR_CONTINUE"); break;
        case  1247 :  sTempString   = _T("An attempt was made to perform an initialization operation when initialization has already been completed.  ERROR_ALREADY_INITIALIZED"); break;
        case  1248 :  sTempString   = _T("No more local devices.  ERROR_NO_MORE_DEVICES"); break;
        case  1249 :  sTempString   = _T("The specified site does not exist.  ERROR_NO_SUCH_SITE"); break;
        case  1250 :  sTempString   = _T("A domain controller with the specified name already exists.  ERROR_DOMAIN_CONTROLLER_EXISTS"); break;
        case  1251 :  sTempString   = _T("This operation is supported only when you are connected to the server. ERROR_ONLY_IF_CONNECTED"); break;
        case  1252 :  sTempString   = _T("The group policy framework should call the extension even if there are no changes. ERROR_OVERRIDE_NOCHANGES"); break;
        case  1253 :  sTempString   = _T("The specified user does not have a valid profile. ERROR_BAD_USER_PROFILE"); break;
        case  1254 :  sTempString   = _T("This operation is not supported on a Microsoft Small Business Server. ERROR_NOT_SUPPORTED_ON_SBS"); break;
        case  1300 :  sTempString   = _T("Not all privileges referenced are assigned to the caller.  ERROR_NOT_ALL_ASSIGNED"); break;
        case  1301 :  sTempString   = _T("Some mapping between account names and security IDs was not done.  ERROR_SOME_NOT_MAPPED"); break;
        case  1302 :  sTempString   = _T("No system quota limits are specifically set for this account.  ERROR_NO_QUOTAS_FOR_ACCOUNT"); break;
        case  1303 :  sTempString   = _T("No encryption key is available. A well-known encryption key was returned.  ERROR_LOCAL_USER_SESSION_KEY"); break;
        case  1304 :  sTempString   = _T("The password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.  ERROR_NULL_LM_PASSWORD"); break;
        case  1305 :  sTempString   = _T("The revision level is unknown.  ERROR_UNKNOWN_REVISION"); break;
        case  1306 :  sTempString   = _T("Indicates two revision levels are incompatible.  ERROR_REVISION_MISMATCH"); break;
        case  1307 :  sTempString   = _T("This security ID may not be assigned as the owner of this object.  ERROR_INVALID_OWNER"); break;
        case  1308 :  sTempString   = _T("This security ID may not be assigned as the primary group of an object.  ERROR_INVALID_PRIMARY_GROUP"); break;
        case  1309 :  sTempString   = _T("An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.  ERROR_NO_IMPERSONATION_TOKEN"); break;
        case  1310 :  sTempString   = _T("The group may not be disabled.  ERROR_CANT_DISABLE_MANDATORY"); break;
        case  1311 :  sTempString   = _T("There are currently no logon servers available to service the logon request.  ERROR_NO_LOGON_SERVERS"); break;
        case  1312 :  sTempString   = _T("A specified logon session does not exist. It may already have been terminated.  ERROR_NO_SUCH_LOGON_SESSION"); break;
        case  1313 :  sTempString   = _T("A specified privilege does not exist.  ERROR_NO_SUCH_PRIVILEGE"); break;
        case  1314 :  sTempString   = _T("A required privilege is not held by the client.  ERROR_PRIVILEGE_NOT_HELD"); break;
        case  1315 :  sTempString   = _T("The name provided is not a properly formed account name.  ERROR_INVALID_ACCOUNT_NAME"); break;
        case  1316 :  sTempString   = _T("The specified user already exists.  ERROR_USER_EXISTS"); break;
        case  1317 :  sTempString   = _T("The specified user does not exist.  ERROR_NO_SUCH_USER"); break;
        case  1318 :  sTempString   = _T("The specified group already exists.  ERROR_GROUP_EXISTS"); break;
        case  1319 :  sTempString   = _T("The specified group does not exist.  ERROR_NO_SUCH_GROUP"); break;
        case  1320 :  sTempString   = _T("Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.  ERROR_MEMBER_IN_GROUP"); break;
        case  1321 :  sTempString   = _T("The specified user account is not a member of the specified group account.  ERROR_MEMBER_NOT_IN_GROUP"); break;
        case  1322 :  sTempString   = _T("The last remaining administration account cannot be disabled or deleted.  ERROR_LAST_ADMIN"); break;
        case  1323 :  sTempString   = _T("Unable to update the password. The value provided as the current password is incorrect.  ERROR_WRONG_PASSWORD"); break;
        case  1324 :  sTempString   = _T("Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.  ERROR_ILL_FORMED_PASSWORD"); break;
        case  1325 :  sTempString   = _T("Unable to update the password. The value provided for the new password does not meet the length, complexity, or history requirement of the domain.  ERROR_PASSWORD_RESTRICTION"); break;
        case  1326 :  sTempString   = _T("Logon failure: unknown user name or bad password.  ERROR_LOGON_FAILURE"); break;
        case  1327 :  sTempString   = _T("Logon failure: user account restriction.  ERROR_ACCOUNT_RESTRICTION"); break;
        case  1328 :  sTempString   = _T("Logon failure: account logon time restriction violation.  ERROR_INVALID_LOGON_HOURS"); break;
        case  1329 :  sTempString   = _T("Logon failure: user not allowed to log on to this computer.  ERROR_INVALID_WORKSTATION"); break;
        case  1330 :  sTempString   = _T("Logon failure: the specified account password has expired.  ERROR_PASSWORD_EXPIRED"); break;
        case  1331 :  sTempString   = _T("Logon failure: account currently disabled.  ERROR_ACCOUNT_DISABLED"); break;
        case  1332 :  sTempString   = _T("No mapping between account names and security IDs was done.  ERROR_NONE_MAPPED"); break;
        case  1333 :  sTempString   = _T("Too many local user identifiers (LUIDs) were requested at one time.  ERROR_TOO_MANY_LUIDS_REQUESTED"); break;
        case  1334 :  sTempString   = _T("No more local user identifiers (LUIDs) are available.  ERROR_LUIDS_EXHAUSTED"); break;
        case  1335 :  sTempString   = _T("The subauthority part of a security ID is invalid for this particular use.  ERROR_INVALID_SUB_AUTHORITY"); break;
        case  1336 :  sTempString   = _T("The access control list (ACL) structure is invalid.  ERROR_INVALID_ACL"); break;
        case  1337 :  sTempString   = _T("The security ID structure is invalid.  ERROR_INVALID_SID"); break;
        case  1338 :  sTempString   = _T("The security descriptor structure is invalid.  ERROR_INVALID_SECURITY_DESCR"); break;
        case  1340 :  sTempString   = _T("The inherited access control list (ACL) or access control entry (ACE) could not be built.  ERROR_BAD_INHERITANCE_ACL"); break;
        case  1341 :  sTempString   = _T("The server is currently disabled.  ERROR_SERVER_DISABLED"); break;
        case  1342 :  sTempString   = _T("The server is currently enabled.  ERROR_SERVER_NOT_DISABLED"); break;
        case  1343 :  sTempString   = _T("The value provided was an invalid value for an identifier authority.  ERROR_INVALID_ID_AUTHORITY"); break;
        case  1344 :  sTempString   = _T("No more memory is available for security information updates.  ERROR_ALLOTTED_SPACE_EXCEEDED"); break;
        case  1345 :  sTempString   = _T("The specified attributes are invalid, or incompatible with the attributes for the group as a whole.  ERROR_INVALID_GROUP_ATTRIBUTES"); break;
        case  1346 :  sTempString   = _T("Either a required impersonation level was not provided, or the provided impersonation level is invalid.  ERROR_BAD_IMPERSONATION_LEVEL"); break;
        case  1347 :  sTempString   = _T("Cannot open an anonymous level security token.  ERROR_CANT_OPEN_ANONYMOUS"); break;
        case  1348 :  sTempString   = _T("The validation information class requested was invalid.  ERROR_BAD_VALIDATION_CLASS"); break;
        case  1349 :  sTempString   = _T("The type of the token is inappropriate for its attempted use.  ERROR_BAD_TOKEN_TYPE"); break;
        case  1350 :  sTempString   = _T("Unable to perform a security operation on an object that has no associated security.  ERROR_NO_SECURITY_ON_OBJECT"); break;
        case  1351 :  sTempString   = _T("Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.  ERROR_CANT_ACCESS_DOMAIN_INFO"); break;
        case  1352 :  sTempString   = _T("The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.  ERROR_INVALID_SERVER_STATE"); break;
        case  1353 :  sTempString   = _T("The domain was in the wrong state to perform the security operation.  ERROR_INVALID_DOMAIN_STATE"); break;
        case  1354 :  sTempString   = _T("This operation is only allowed for the Primary Domain Controller of the domain.  ERROR_INVALID_DOMAIN_ROLE"); break;
        case  1355 :  sTempString   = _T("The specified domain either does not exist or could not be contacted.  ERROR_NO_SUCH_DOMAIN"); break;
        case  1356 :  sTempString   = _T("The specified domain already exists.  ERROR_DOMAIN_EXISTS"); break;
        case  1357 :  sTempString   = _T("An attempt was made to exceed the limit on the number of domains per server.  ERROR_DOMAIN_LIMIT_EXCEEDED"); break;
        case  1358 :  sTempString   = _T("Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.  ERROR_INTERNAL_DB_CORRUPTION"); break;
        case  1359 :  sTempString   = _T("An internal error occurred. ERROR_INTERNAL_ERROR"); break;
        case  1360 :  sTempString   = _T("Generic access types were contained in an access mask which should already be mapped to nongeneric types.  ERROR_GENERIC_NOT_MAPPED"); break;
        case  1361 :  sTempString   = _T("A security descriptor is not in the right format (absolute or self-relative).  ERROR_BAD_DESCRIPTOR_FORMAT"); break;
        case  1362 :  sTempString   = _T("The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.  ERROR_NOT_LOGON_PROCESS"); break;
        case  1363 :  sTempString   = _T("Cannot start a new logon session with an ID that is already in use.  ERROR_LOGON_SESSION_EXISTS"); break;
        case  1364 :  sTempString   = _T("A specified authentication package is unknown.  ERROR_NO_SUCH_PACKAGE"); break;
        case  1365 :  sTempString   = _T("The logon session is not in a state that is consistent with the requested operation.  ERROR_BAD_LOGON_SESSION_STATE"); break;
        case  1366 :  sTempString   = _T("The logon session ID is already in use.  ERROR_LOGON_SESSION_COLLISION"); break;
        case  1367 :  sTempString   = _T("A logon request contained an invalid logon type value.  ERROR_INVALID_LOGON_TYPE"); break;
        case  1368 :  sTempString   = _T("Unable to impersonate using a named pipe until data has been read from that pipe.  ERROR_CANNOT_IMPERSONATE"); break;
        case  1369 :  sTempString   = _T("The transaction state of a registry subtree is incompatible with the requested operation.  ERROR_RXACT_INVALID_STATE"); break;
        case  1370 :  sTempString   = _T("An internal security database corruption has been encountered.  ERROR_RXACT_COMMIT_FAILURE"); break;
        case  1371 :  sTempString   = _T("Cannot perform this operation on built-in accounts.  ERROR_SPECIAL_ACCOUNT"); break;
        case  1372 :  sTempString   = _T("Cannot perform this operation on this built-in special group.  ERROR_SPECIAL_GROUP"); break;
        case  1373 :  sTempString   = _T("Cannot perform this operation on this built-in special user.  ERROR_SPECIAL_USER"); break;
        case  1374 :  sTempString   = _T("The user cannot be removed from a group because the group is currently the user's primary group.  ERROR_MEMBERS_PRIMARY_GROUP"); break;
        case  1375 :  sTempString   = _T("The token is already in use as a primary token.  ERROR_TOKEN_ALREADY_IN_USE"); break;
        case  1376 :  sTempString   = _T("The specified local group does not exist.  ERROR_NO_SUCH_ALIAS"); break;
        case  1377 :  sTempString   = _T("The specified account name is not a member of the local group.  ERROR_MEMBER_NOT_IN_ALIAS"); break;
        case  1378 :  sTempString   = _T("The specified account name is already a member of the local group.  ERROR_MEMBER_IN_ALIAS"); break;
        case  1379 :  sTempString   = _T("The specified local group already exists.  ERROR_ALIAS_EXISTS"); break;
        case  1380 :  sTempString   = _T("Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_NOT_GRANTED"); break;
        case  1381 :  sTempString   = _T("The maximum number of secrets that may be stored in a single system has been exceeded.  ERROR_TOO_MANY_SECRETS"); break;
        case  1382 :  sTempString   = _T("The length of a secret exceeds the maximum length allowed.  ERROR_SECRET_TOO_LONG"); break;
        case  1383 :  sTempString   = _T("The local security authority database contains an internal inconsistency.  ERROR_INTERNAL_DB_ERROR"); break;
        case  1384 :  sTempString   = _T("During a logon attempt, the user's security context accumulated too many security IDs.  ERROR_TOO_MANY_CONTEXT_IDS"); break;
        case  1385 :  sTempString   = _T("Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_TYPE_NOT_GRANTED"); break;
        case  1386 :  sTempString   = _T("A cross-encrypted password is necessary to change a user password.  ERROR_NT_CROSS_ENCRYPTION_REQUIRED"); break;
        case  1387 :  sTempString   = _T("A new member could not be added to or removed from the local group because the member does not exist.  ERROR_NO_SUCH_MEMBER"); break;
        case  1388 :  sTempString   = _T("A new member could not be added to a local group because the member has the wrong account type.  ERROR_INVALID_MEMBER"); break;
        case  1389 :  sTempString   = _T("Too many security IDs have been specified.  ERROR_TOO_MANY_SIDS"); break;
        case  1390 :  sTempString   = _T("A cross-encrypted password is necessary to change this user password.  ERROR_LM_CROSS_ENCRYPTION_REQUIRED"); break;
        case  1391 :  sTempString   = _T("Indicates an ACL contains no inheritable components.  ERROR_NO_INHERITANCE"); break;
        case  1392 :  sTempString   = _T("The file or directory is corrupted and unreadable.  ERROR_FILE_CORRUPT"); break;
        case  1393 :  sTempString   = _T("The disk structure is corrupted and unreadable.  ERROR_DISK_CORRUPT"); break;
        case  1394 :  sTempString   = _T("There is no user session key for the specified logon session.  ERROR_NO_USER_SESSION_KEY"); break;
        case  1395 :  sTempString   = _T("The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.  ERROR_LICENSE_QUOTA_EXCEEDED"); break;
        case  1396 :  sTempString   = _T("Logon Failure: The target account name is incorrect.  ERROR_WRONG_TARGET_NAME"); break;
        case  1397 :  sTempString   = _T("Mutual Authentication failed. The server's password is out of date at the domain controller.  ERROR_MUTUAL_AUTH_FAILED"); break;
        case  1398 :  sTempString   = _T("There is a time difference between the client and server.  ERROR_TIME_SKEW"); break;
        case  1400 :  sTempString   = _T("Invalid window handle.  ERROR_INVALID_WINDOW_HANDLE"); break;
        case  1401 :  sTempString   = _T("Invalid menu handle.  ERROR_INVALID_MENU_HANDLE"); break;
        case  1402 :  sTempString   = _T("Invalid cursor handle.  ERROR_INVALID_CURSOR_HANDLE"); break;
        case  1403 :  sTempString   = _T("Invalid accelerator table handle.  ERROR_INVALID_ACCEL_HANDLE"); break;
        case  1404 :  sTempString   = _T("Invalid hook handle.  ERROR_INVALID_HOOK_HANDLE"); break;
        case  1405 :  sTempString   = _T("Invalid handle to a multiple-window position structure.  ERROR_INVALID_DWP_HANDLE"); break;
        case  1406 :  sTempString   = _T("Cannot create a top-level child window.  ERROR_TLW_WITH_WSCHILD"); break;
        case  1407 :  sTempString   = _T("Cannot find window class.  ERROR_CANNOT_FIND_WND_CLASS"); break;
        case  1408 :  sTempString   = _T("Invalid window; it belongs to other thread.  ERROR_WINDOW_OF_OTHER_THREAD"); break;
        case  1409 :  sTempString   = _T("Hot key is already registered.  ERROR_HOTKEY_ALREADY_REGISTERED"); break;
        case  1410 :  sTempString   = _T("Class already exists.  ERROR_CLASS_ALREADY_EXISTS"); break;
        case  1411 :  sTempString   = _T("Class does not exist.  ERROR_CLASS_DOES_NOT_EXIST"); break;
        case  1412 :  sTempString   = _T("Class still has open windows.  ERROR_CLASS_HAS_WINDOWS"); break;
        case  1413 :  sTempString   = _T("Invalid index.  ERROR_INVALID_INDEX"); break;
        case  1414 :  sTempString   = _T("Invalid icon handle.  ERROR_INVALID_ICON_HANDLE"); break;
        case  1415 :  sTempString   = _T("Using private DIALOG window words.  ERROR_PRIVATE_DIALOG_INDEX"); break;
        case  1416 :  sTempString   = _T("The list box identifier was not found.  ERROR_LISTBOX_ID_NOT_FOUND"); break;
        case  1417 :  sTempString   = _T("No wildcards were found.  ERROR_NO_WILDCARD_CHARACTERS"); break;
        case  1418 :  sTempString   = _T("Thread does not have a clipboard open.  ERROR_CLIPBOARD_NOT_OPEN"); break;
        case  1419 :  sTempString   = _T("Hot key is not registered.  ERROR_HOTKEY_NOT_REGISTERED"); break;
        case  1420 :  sTempString   = _T("The window is not a valid dialog window.  ERROR_WINDOW_NOT_DIALOG"); break;
        case  1421 :  sTempString   = _T("Control ID not found.  ERROR_CONTROL_ID_NOT_FOUND"); break;
        case  1422 :  sTempString   = _T("Invalid message for a combo box because it does not have an edit control.  ERROR_INVALID_COMBOBOX_MESSAGE"); break;
        case  1423 :  sTempString   = _T("The window is not a combo box.  ERROR_WINDOW_NOT_COMBOBOX"); break;
        case  1424 :  sTempString   = _T("Height must be less than 256.  ERROR_INVALID_EDIT_HEIGHT"); break;
        case  1425 :  sTempString   = _T("Invalid device context (DC) handle.  ERROR_DC_NOT_FOUND"); break;
        case  1426 :  sTempString   = _T("Invalid hook procedure type.  ERROR_INVALID_HOOK_FILTER"); break;
        case  1427 :  sTempString   = _T("Invalid hook procedure.  ERROR_INVALID_FILTER_PROC"); break;
        case  1428 :  sTempString   = _T("Cannot set nonlocal hook without a module handle.  ERROR_HOOK_NEEDS_HMOD"); break;
        case  1429 :  sTempString   = _T("This hook procedure can only be set globally.  ERROR_GLOBAL_ONLY_HOOK"); break;
        case  1430 :  sTempString   = _T("The journal hook procedure is already installed.  ERROR_JOURNAL_HOOK_SET"); break;
        case  1431 :  sTempString   = _T("The hook procedure is not installed.  ERROR_HOOK_NOT_INSTALLED"); break;
        case  1432 :  sTempString   = _T("Invalid message for single-selection list box.  ERROR_INVALID_LB_MESSAGE"); break;
        case  1433 :  sTempString   = _T("LB_SETCOUNT sent to non-lazy list box.  ERROR_SETCOUNT_ON_BAD_LB"); break;
        case  1434 :  sTempString   = _T("This list box does not support tab stops.  ERROR_LB_WITHOUT_TABSTOPS"); break;
        case  1435 :  sTempString   = _T("Cannot destroy object created by another thread.  ERROR_DESTROY_OBJECT_OF_OTHER_THREAD"); break;
        case  1436 :  sTempString   = _T("Child windows cannot have menus.  ERROR_CHILD_WINDOW_MENU"); break;
        case  1437 :  sTempString   = _T("The window does not have a system menu.  ERROR_NO_SYSTEM_MENU"); break;
        case  1438 :  sTempString   = _T("Invalid message box style.  ERROR_INVALID_MSGBOX_STYLE"); break;
        case  1439 :  sTempString   = _T("Invalid system-wide (SPI_*) parameter.  ERROR_INVALID_SPI_VALUE"); break;
        case  1440 :  sTempString   = _T("Screen already locked.  ERROR_SCREEN_ALREADY_LOCKED"); break;
        case  1441 :  sTempString   = _T("All handles to windows in a multiple-window position structure must have the same parent.  ERROR_HWNDS_HAVE_DIFF_PARENT"); break;
        case  1442 :  sTempString   = _T("The window is not a child window.  ERROR_NOT_CHILD_WINDOW"); break;
        case  1443 :  sTempString   = _T("Invalid GW_* command.  ERROR_INVALID_GW_COMMAND"); break;
        case  1444 :  sTempString   = _T("Invalid thread identifier.  ERROR_INVALID_THREAD_ID"); break;
        case  1445 :  sTempString   = _T("Cannot process a message from a window that is not a multiple document interface (MDI) window.  ERROR_NON_MDICHILD_WINDOW"); break;
        case  1446 :  sTempString   = _T("Popup menu already active.  ERROR_POPUP_ALREADY_ACTIVE"); break;
        case  1447 :  sTempString   = _T("The window does not have scroll bars.  ERROR_NO_SCROLLBARS"); break;
        case  1448 :  sTempString   = _T("Scroll bar range cannot be greater than MAXLONG.  ERROR_INVALID_SCROLLBAR_RANGE"); break;
        case  1449 :  sTempString   = _T("Cannot show or remove the window in the way specified.  ERROR_INVALID_SHOWWIN_COMMAND"); break;
        case  1450 :  sTempString   = _T("Insufficient system resources exist to complete the requested service.  ERROR_NO_SYSTEM_RESOURCES"); break;
        case  1451 :  sTempString   = _T("Insufficient system resources exist to complete the requested service.  ERROR_NONPAGED_SYSTEM_RESOURCES"); break;
        case  1452 :  sTempString   = _T("Insufficient system resources exist to complete the requested service.  ERROR_PAGED_SYSTEM_RESOURCES"); break;
        case  1453 :  sTempString   = _T("Insufficient quota to complete the requested service.  ERROR_WORKING_SET_QUOTA"); break;
        case  1454 :  sTempString   = _T("Insufficient quota to complete the requested service.  ERROR_PAGEFILE_QUOTA"); break;
        case  1455 :  sTempString   = _T("The paging file is too small for this operation to complete.  ERROR_COMMITMENT_LIMIT"); break;
        case  1456 :  sTempString   = _T("A menu item was not found.  ERROR_MENU_ITEM_NOT_FOUND"); break;
        case  1457 :  sTempString   = _T("Invalid keyboard layout handle.  ERROR_INVALID_KEYBOARD_HANDLE"); break;
        case  1458 :  sTempString   = _T("Hook type not allowed.  ERROR_HOOK_TYPE_NOT_ALLOWED"); break;
        case  1459 :  sTempString   = _T("This operation requires an interactive window station.  ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION"); break;
        case  1460 :  sTempString   = _T("This operation returned because the timeout period expired.  ERROR_TIMEOUT"); break;
        case  1461 :  sTempString   = _T("Invalid monitor handle.  ERROR_INVALID_MONITOR_HANDLE"); break;
        case  1500 :  sTempString   = _T("The event log file is corrupted.  ERROR_EVENTLOG_FILE_CORRUPT"); break;
        case  1501 :  sTempString   = _T("No event log file could be opened, so the event logging service did not start.  ERROR_EVENTLOG_CANT_START"); break;
        case  1502 :  sTempString   = _T("The event log file is full.  ERROR_LOG_FILE_FULL"); break;
        case  1503 :  sTempString   = _T("The event log file has changed between read operations.  ERROR_EVENTLOG_FILE_CHANGED"); break;
        case  1601 :  sTempString   = _T("The Windows Installer service could not be accessed. Contact your support personnel to verify that the Windows Installer service is properly registered. ERROR_INSTALL_SERVICE_FAILURE"); break;
        case  1602 :  sTempString   = _T("User cancelled installation.  ERROR_INSTALL_USEREXIT"); break;
        case  1603 :  sTempString   = _T("Fatal error during installation.  ERROR_INSTALL_FAILURE"); break;
        case  1604 :  sTempString   = _T("Installation suspended, incomplete.  ERROR_INSTALL_SUSPEND"); break;
        case  1605 :  sTempString   = _T("This action is only valid for products that are currently installed.  ERROR_UNKNOWN_PRODUCT"); break;
        case  1606 :  sTempString   = _T("Feature ID not registered.  ERROR_UNKNOWN_FEATURE"); break;
        case  1607 :  sTempString   = _T("Component ID not registered.  ERROR_UNKNOWN_COMPONENT"); break;
        case  1608 :  sTempString   = _T("Unknown property.  ERROR_UNKNOWN_PROPERTY"); break;
        case  1609 :  sTempString   = _T("Handle is in an invalid state.  ERROR_INVALID_HANDLE_STATE"); break;
        case  1610 :  sTempString   = _T("The configuration data for this product is corrupt. Contact your support personnel.  ERROR_BAD_CONFIGURATION"); break;
        case  1611 :  sTempString   = _T("Component qualifier not present.  ERROR_INDEX_ABSENT"); break;
        case  1612 :  sTempString   = _T("The installation source for this product is not available. Verify that the source exists and that you can access it.  ERROR_INSTALL_SOURCE_ABSENT"); break;
        case  1613 :  sTempString   = _T("This installation package cannot be installed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service.  ERROR_INSTALL_PACKAGE_VERSION"); break;
        case  1614 :  sTempString   = _T("Product is uninstalled.  ERROR_PRODUCT_UNINSTALLED"); break;
        case  1615 :  sTempString   = _T("SQL query syntax invalid or unsupported.  ERROR_BAD_QUERY_SYNTAX"); break;
        case  1616 :  sTempString   = _T("Record field does not exist.  ERROR_INVALID_FIELD"); break;
        case  1617 :  sTempString   = _T("The device has been removed.  ERROR_DEVICE_REMOVED"); break;
        case  1618 :  sTempString   = _T("Another installation is already in progress. Complete that installation before proceeding with this install.  ERROR_INSTALL_ALREADY_RUNNING"); break;
        case  1619 :  sTempString   = _T("This installation package could not be opened. Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.  ERROR_INSTALL_PACKAGE_OPEN_FAILED"); break;
        case  1620 :  sTempString   = _T("This installation package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer package.  ERROR_INSTALL_PACKAGE_INVALID"); break;
        case  1621 :  sTempString   = _T("There was an error starting the Windows Installer service user interface. Contact your support personnel.  ERROR_INSTALL_UI_FAILURE"); break;
        case  1622 :  sTempString   = _T("Error opening installation log file. Verify that the specified log file location exists and that you can write to it.  ERROR_INSTALL_LOG_FAILURE"); break;
        case  1623 :  sTempString   = _T("The language of this installation package is not supported by your system.  ERROR_INSTALL_LANGUAGE_UNSUPPORTED"); break;
        case  1624 :  sTempString   = _T("Error applying transforms. Verify that the specified transform paths are valid.  ERROR_INSTALL_TRANSFORM_FAILURE"); break;
        case  1625 :  sTempString   = _T("This installation is forbidden by system policy. Contact your system administrator.  ERROR_INSTALL_PACKAGE_REJECTED"); break;
        case  1626 :  sTempString   = _T("Function could not be executed. ERROR_FUNCTION_NOT_CALLED"); break;
        case  1627 :  sTempString   = _T("Function failed during execution. ERROR_FUNCTION_FAILED"); break;
        case  1628 :  sTempString   = _T("Invalid or unknown table specified. ERROR_INVALID_TABLE"); break;
        case  1629 :  sTempString   = _T("Data supplied is of wrong type. ERROR_DATATYPE_MISMATCH"); break;
        case  1630 :  sTempString   = _T("Data of this type is not supported. ERROR_UNSUPPORTED_TYPE"); break;
        case  1631 :  sTempString   = _T("The Windows Installer service failed to start. Contact your support personnel.  ERROR_CREATE_FAILED"); break;
        case  1632 :  sTempString   = _T("The temp folder is either full or inaccessible. Verify that the temp folder exists and that you can write to it.  ERROR_INSTALL_TEMP_UNWRITABLE"); break;
        case  1633 :  sTempString   = _T("This installation package is not supported by this processor type. Contact your product vendor.  ERROR_INSTALL_PLATFORM_UNSUPPORTED"); break;
        case  1634 :  sTempString   = _T("Component not used on this computer. ERROR_INSTALL_NOTUSED"); break;
        case  1635 :  sTempString   = _T("This patch package could not be opened. Verify that the patch package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer patch package.  ERROR_PATCH_PACKAGE_OPEN_FAILED"); break;
        case  1636 :  sTempString   = _T("This patch package could not be opened. Contact the application vendor to verify that this is a valid Windows Installer patch package.  ERROR_PATCH_PACKAGE_INVALID"); break;
        case  1637 :  sTempString   = _T("This patch package cannot be processed by the Windows Installer service. You must install a Windows service pack that contains a newer version of the Windows Installer service. ERROR_PATCH_PACKAGE_UNSUPPORTED."); break;
        case  1638 :  sTempString   = _T("Another version of this product is already installed. Installation of this version cannot continue. To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.  ERROR_PRODUCT_VERSION"); break;
        case  1639 :  sTempString   = _T("Invalid command line argument. Consult the Windows Installer SDK for detailed command line help.  ERROR_INVALID_COMMAND_LINE"); break;
        case  1640 :  sTempString   = _T("Only administrators have permission to add, remove, or configure server software during a Terminal Services remote session. If you want to install or configure software on the server, contact your network administrator. ERROR_INSTALL_REMOTE_DISALLOWED"); break;
        case  1641 :  sTempString   = _T("The requested operation completed successfully. The system will be restarted so the changes can take effect. ERROR_SUCCESS_REBOOT_INITIATED"); break;
        case  1642 :  sTempString   = _T("The upgrade patch cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade patch may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade patch."); break;
        case  1700 :  sTempString   = _T("The string binding is invalid.  RPC_S_INVALID_STRING_BINDING"); break;
        case  1701 :  sTempString   = _T("The binding handle is not the correct type.  RPC_S_WRONG_KIND_OF_BINDING"); break;
        case  1702 :  sTempString   = _T("The binding handle is invalid.  RPC_S_INVALID_BINDING"); break;
        case  1703 :  sTempString   = _T("The RPC protocol sequence is not supported.  RPC_S_PROTSEQ_NOT_SUPPORTED"); break;
        case  1704 :  sTempString   = _T("The RPC protocol sequence is invalid.  RPC_S_INVALID_RPC_PROTSEQ"); break;
        case  1705 :  sTempString   = _T("The string universal unique identifier (UUID) is invalid.  RPC_S_INVALID_STRING_UUID"); break;
        case  1706 :  sTempString   = _T("The endpoint format is invalid.  RPC_S_INVALID_ENDPOINT_FORMAT"); break;
        case  1707 :  sTempString   = _T("The network address is invalid.  RPC_S_INVALID_NET_ADDR"); break;
        case  1708 :  sTempString   = _T("No endpoint was found.  RPC_S_NO_ENDPOINT_FOUND"); break;
        case  1709 :  sTempString   = _T("The timeout value is invalid.  RPC_S_INVALID_TIMEOUT"); break;
        case  1710 :  sTempString   = _T("The object universal unique identifier (UUID) was not found.  RPC_S_OBJECT_NOT_FOUND"); break;
        case  1711 :  sTempString   = _T("The object universal unique identifier (UUID) has already been registered.  RPC_S_ALREADY_REGISTERED"); break;
        case  1712 :  sTempString   = _T("The type universal unique identifier (UUID) has already been registered.  RPC_S_TYPE_ALREADY_REGISTERED"); break;
        case  1713 :  sTempString   = _T("The RPC server is already listening.  RPC_S_ALREADY_LISTENING"); break;
        case  1714 :  sTempString   = _T("No protocol sequences have been registered.  RPC_S_NO_PROTSEQS_REGISTERED"); break;
        case  1715 :  sTempString   = _T("The RPC server is not listening.  RPC_S_NOT_LISTENING"); break;
        case  1716 :  sTempString   = _T("The manager type is unknown.  RPC_S_UNKNOWN_MGR_TYPE"); break;
        case  1717 :  sTempString   = _T("The interface is unknown.  RPC_S_UNKNOWN_IF"); break;
        case  1718 :  sTempString   = _T("There are no bindings.  RPC_S_NO_BINDINGS"); break;
        case  1719 :  sTempString   = _T("There are no protocol sequences.  RPC_S_NO_PROTSEQS"); break;
        case  1720 :  sTempString   = _T("The endpoint cannot be created.  RPC_S_CANT_CREATE_ENDPOINT"); break;
        case  1721 :  sTempString   = _T("Not enough resources are available to complete this operation.  RPC_S_OUT_OF_RESOURCES"); break;
        case  1722 :  sTempString   = _T("The RPC server is unavailable.  RPC_S_SERVER_UNAVAILABLE"); break;
        case  1723 :  sTempString   = _T("The RPC server is too busy to complete this operation.  RPC_S_SERVER_TOO_BUSY"); break;
        case  1724 :  sTempString   = _T("The network options are invalid.  RPC_S_INVALID_NETWORK_OPTIONS"); break;
        case  1725 :  sTempString   = _T("There are no remote procedure calls active on this thread.  RPC_S_NO_CALL_ACTIVE"); break;
        case  1726 :  sTempString   = _T("The remote procedure call failed.  RPC_S_CALL_FAILED"); break;
        case  1727 :  sTempString   = _T("The remote procedure call failed and did not execute.  RPC_S_CALL_FAILED_DNE"); break;
        case  1728 :  sTempString   = _T("A remote procedure call (RPC) protocol error occurred.  RPC_S_PROTOCOL_ERROR"); break;
        case  1730 :  sTempString   = _T("The transfer syntax is not supported by the RPC server.  RPC_S_UNSUPPORTED_TRANS_SYN"); break;
        case  1732 :  sTempString   = _T("The universal unique identifier (UUID) type is not supported.  RPC_S_UNSUPPORTED_TYPE"); break;
        case  1733 :  sTempString   = _T("The tag is invalid.  RPC_S_INVALID_TAG"); break;
        case  1734 :  sTempString   = _T("The array bounds are invalid.  RPC_S_INVALID_BOUND"); break;
        case  1735 :  sTempString   = _T("The binding does not contain an entry name.  RPC_S_NO_ENTRY_NAME"); break;
        case  1736 :  sTempString   = _T("The name syntax is invalid.  RPC_S_INVALID_NAME_SYNTAX"); break;
        case  1737 :  sTempString   = _T("The name syntax is not supported.  RPC_S_UNSUPPORTED_NAME_SYNTAX"); break;
        case  1739 :  sTempString   = _T("No network address is available to use to construct a universal unique identifier (UUID).  RPC_S_UUID_NO_ADDRESS"); break;
        case  1740 :  sTempString   = _T("The endpoint is a duplicate.  RPC_S_DUPLICATE_ENDPOINT"); break;
        case  1741 :  sTempString   = _T("The authentication type is unknown.  RPC_S_UNKNOWN_AUTHN_TYPE"); break;
        case  1742 :  sTempString   = _T("The maximum number of calls is too small.  RPC_S_MAX_CALLS_TOO_SMALL"); break;
        case  1743 :  sTempString   = _T("The string is too long.  RPC_S_STRING_TOO_LONG"); break;
        case  1744 :  sTempString   = _T("The RPC protocol sequence was not found.  RPC_S_PROTSEQ_NOT_FOUND"); break;
        case  1745 :  sTempString   = _T("The procedure number is out of range.  RPC_S_PROCNUM_OUT_OF_RANGE"); break;
        case  1746 :  sTempString   = _T("The binding does not contain any authentication information.  RPC_S_BINDING_HAS_NO_AUTH"); break;
        case  1747 :  sTempString   = _T("The authentication service is unknown.  RPC_S_UNKNOWN_AUTHN_SERVICE"); break;
        case  1748 :  sTempString   = _T("The authentication level is unknown.  RPC_S_UNKNOWN_AUTHN_LEVEL"); break;
        case  1749 :  sTempString   = _T("The security context is invalid.  RPC_S_INVALID_AUTH_IDENTITY"); break;
        case  1750 :  sTempString   = _T("The authorization service is unknown.  RPC_S_UNKNOWN_AUTHZ_SERVICE"); break;
        case  1751 :  sTempString   = _T("The entry is invalid.  EPT_S_INVALID_ENTRY"); break;
        case  1752 :  sTempString   = _T("The server endpoint cannot perform the operation.  EPT_S_CANT_PERFORM_OP"); break;
        case  1753 :  sTempString   = _T("There are no more endpoints available from the endpoint mapper.  EPT_S_NOT_REGISTERED"); break;
        case  1754 :  sTempString   = _T("No interfaces have been exported.  RPC_S_NOTHING_TO_EXPORT"); break;
        case  1755 :  sTempString   = _T("The entry name is incomplete.  RPC_S_INCOMPLETE_NAME"); break;
        case  1756 :  sTempString   = _T("The version option is invalid.  RPC_S_INVALID_VERS_OPTION"); break;
        case  1757 :  sTempString   = _T("There are no more members.  RPC_S_NO_MORE_MEMBERS"); break;
        case  1758 :  sTempString   = _T("There is nothing to unexport.  RPC_S_NOT_ALL_OBJS_UNEXPORTED"); break;
        case  1759 :  sTempString   = _T("The interface was not found.  RPC_S_INTERFACE_NOT_FOUND"); break;
        case  1760 :  sTempString   = _T("The entry already exists.  RPC_S_ENTRY_ALREADY_EXISTS"); break;
        case  1761 :  sTempString   = _T("The entry is not found.  RPC_S_ENTRY_NOT_FOUND"); break;
        case  1762 :  sTempString   = _T("The name service is unavailable.  RPC_S_NAME_SERVICE_UNAVAILABLE"); break;
        case  1763 :  sTempString   = _T("The network address family is invalid.  RPC_S_INVALID_NAF_ID"); break;
        case  1764 :  sTempString   = _T("The requested operation is not supported.  RPC_S_CANNOT_SUPPORT"); break;
        case  1765 :  sTempString   = _T("No security context is available to allow impersonation.  RPC_S_NO_CONTEXT_AVAILABLE"); break;
        case  1766 :  sTempString   = _T("An internal error occurred in a remote procedure call (RPC).  RPC_S_INTERNAL_ERROR"); break;
        case  1767 :  sTempString   = _T("The RPC server attempted an integer division by zero.  RPC_S_ZERO_DIVIDE"); break;
        case  1768 :  sTempString   = _T("An addressing error occurred in the RPC server.  RPC_S_ADDRESS_ERROR"); break;
        case  1769 :  sTempString   = _T("A floating-point operation at the RPC server caused a division by zero.  RPC_S_FP_DIV_ZERO"); break;
        case  1770 :  sTempString   = _T("A floating-point underflow occurred at the RPC server.  RPC_S_FP_UNDERFLOW"); break;
        case  1771 :  sTempString   = _T("A floating-point overflow occurred at the RPC server.  RPC_S_FP_OVERFLOW"); break;
        case  1772 :  sTempString   = _T("The list of RPC servers available for the binding of auto handles has been exhausted.  RPC_X_NO_MORE_ENTRIES"); break;
        case  1773 :  sTempString   = _T("Unable to open the character translation table file.  RPC_X_SS_CHAR_TRANS_OPEN_FAIL"); break;
        case  1774 :  sTempString   = _T("The file containing the character translation table has fewer than 512 bytes.  RPC_X_SS_CHAR_TRANS_SHORT_FILE"); break;
        case  1775 :  sTempString   = _T("A null context handle was passed from the client to the host during a remote procedure call.  RPC_X_SS_IN_NULL_CONTEXT"); break;
        case  1777 :  sTempString   = _T("The context handle changed during a remote procedure call.  RPC_X_SS_CONTEXT_DAMAGED"); break;
        case  1778 :  sTempString   = _T("The binding handles passed to a remote procedure call do not match.  RPC_X_SS_HANDLES_MISMATCH"); break;
        case  1779 :  sTempString   = _T("The stub is unable to get the remote procedure call handle.  RPC_X_SS_CANNOT_GET_CALL_HANDLE"); break;
        case  1780 :  sTempString   = _T("A null reference pointer was passed to the stub.  RPC_X_NULL_REF_POINTER"); break;
        case  1781 :  sTempString   = _T("The enumeration value is out of range.  RPC_X_ENUM_VALUE_OUT_OF_RANGE"); break;
        case  1782 :  sTempString   = _T("The byte count is too small.  RPC_X_BYTE_COUNT_TOO_SMALL"); break;
        case  1783 :  sTempString   = _T("The stub received bad data.  RPC_X_BAD_STUB_DATA"); break;
        case  1784 :  sTempString   = _T("The supplied user buffer is not valid for the requested operation.  ERROR_INVALID_USER_BUFFER"); break;
        case  1785 :  sTempString   = _T("The disk media is not recognized. It may not be formatted.  ERROR_UNRECOGNIZED_MEDIA"); break;
        case  1786 :  sTempString   = _T("The workstation does not have a trust secret.  ERROR_NO_TRUST_LSA_SECRET"); break;
        case  1787 :  sTempString   = _T("The security database on the server does not have a computer account for this workstation trust relationship.  ERROR_NO_TRUST_SAM_ACCOUNT"); break;
        case  1788 :  sTempString   = _T("The trust relationship between the primary domain and the trusted domain failed.  ERROR_TRUSTED_DOMAIN_FAILURE"); break;
        case  1789 :  sTempString   = _T("The trust relationship between this workstation and the primary domain failed.  ERROR_TRUSTED_RELATIONSHIP_FAILURE"); break;
        case  1790 :  sTempString   = _T("The network logon failed.  ERROR_TRUST_FAILURE"); break;
        case  1791 :  sTempString   = _T("A remote procedure call is already in progress for this thread.  RPC_S_CALL_IN_PROGRESS"); break;
        case  1792 :  sTempString   = _T("An attempt was made to logon, but the network logon service was not started.  ERROR_NETLOGON_NOT_STARTED"); break;
        case  1793 :  sTempString   = _T("The user's account has expired.  ERROR_ACCOUNT_EXPIRED"); break;
        case  1794 :  sTempString   = _T("The redirector is in use and cannot be unloaded.  ERROR_REDIRECTOR_HAS_OPEN_HANDLES"); break;
        case  1795 :  sTempString   = _T("The specified printer driver is already installed.  ERROR_PRINTER_DRIVER_ALREADY_INSTALLED"); break;
        case  1796 :  sTempString   = _T("The specified port is unknown.  ERROR_UNKNOWN_PORT"); break;
        case  1797 :  sTempString   = _T("The printer driver is unknown.  ERROR_UNKNOWN_PRINTER_DRIVER"); break;
        case  1798 :  sTempString   = _T("The print processor is unknown.  ERROR_UNKNOWN_PRINTPROCESSOR"); break;
        case  1799 :  sTempString   = _T("The specified separator file is invalid.  ERROR_INVALID_SEPARATOR_FILE"); break;
        case  1800 :  sTempString   = _T("The specified priority is invalid.  ERROR_INVALID_PRIORITY"); break;
        case  1801 :  sTempString   = _T("The printer name is invalid.  ERROR_INVALID_PRINTER_NAME"); break;
        case  1802 :  sTempString   = _T("The printer already exists.  ERROR_PRINTER_ALREADY_EXISTS"); break;
        case  1803 :  sTempString   = _T("The printer command is invalid.  ERROR_INVALID_PRINTER_COMMAND"); break;
        case  1804 :  sTempString   = _T("The specified datatype is invalid.  ERROR_INVALID_DATATYPE"); break;
        case  1805 :  sTempString   = _T("The environment specified is invalid.  ERROR_INVALID_ENVIRONMENT"); break;
        case  1806 :  sTempString   = _T("There are no more bindings.  RPC_S_NO_MORE_BINDINGS"); break;
        case  1807 :  sTempString   = _T("The account used is an interdomain trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT"); break;
        case  1808 :  sTempString   = _T("The account used is a computer account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT"); break;
        case  1809 :  sTempString   = _T("The account used is a server trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_SERVER_TRUST_ACCOUNT"); break;
        case  1810 :  sTempString   = _T("The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.  ERROR_DOMAIN_TRUST_INCONSISTENT"); break;
        case  1811 :  sTempString   = _T("The server is in use and cannot be unloaded.  ERROR_SERVER_HAS_OPEN_HANDLES"); break;
        case  1812 :  sTempString   = _T("The specified image file did not contain a resource section.  ERROR_RESOURCE_DATA_NOT_FOUND"); break;
        case  1813 :  sTempString   = _T("The specified resource type cannot be found in the image file.  ERROR_RESOURCE_TYPE_NOT_FOUND"); break;
        case  1814 :  sTempString   = _T("The specified resource name cannot be found in the image file.  ERROR_RESOURCE_NAME_NOT_FOUND"); break;
        case  1815 :  sTempString   = _T("The specified resource language ID cannot be found in the image file.  ERROR_RESOURCE_LANG_NOT_FOUND"); break;
        case  1816 :  sTempString   = _T("Not enough quota is available to process this command.  ERROR_NOT_ENOUGH_QUOTA"); break;
        case  1817 :  sTempString   = _T("No interfaces have been registered.  RPC_S_NO_INTERFACES"); break;
        case  1818 :  sTempString   = _T("The remote procedure call was cancelled.  RPC_S_CALL_CANCELLED"); break;
        case  1819 :  sTempString   = _T("The binding handle does not contain all required information.  RPC_S_BINDING_INCOMPLETE"); break;
        case  1820 :  sTempString   = _T("A communications failure occurred during a remote procedure call.  RPC_S_COMM_FAILURE"); break;
        case  1821 :  sTempString   = _T("The requested authentication level is not supported.  RPC_S_UNSUPPORTED_AUTHN_LEVEL"); break;
        case  1822 :  sTempString   = _T("No principal name registered.  RPC_S_NO_PRINC_NAME"); break;
        case  1823 :  sTempString   = _T("The error specified is not a valid Windows RPC error code.  RPC_S_NOT_RPC_ERROR"); break;
        case  1824 :  sTempString   = _T("A UUID that is valid only on this computer has been allocated.  RPC_S_UUID_LOCAL_ONLY"); break;
        case  1825 :  sTempString   = _T("A security package specific error occurred.  RPC_S_SEC_PKG_ERROR"); break;
        case  1826 :  sTempString   = _T("Thread is not canceled.  RPC_S_NOT_CANCELLED"); break;
        case  1827 :  sTempString   = _T("Invalid operation on the encoding/decoding handle.  RPC_X_INVALID_ES_ACTION"); break;
        case  1828 :  sTempString   = _T("Incompatible version of the serializing package.  RPC_X_WRONG_ES_VERSION"); break;
        case  1829 :  sTempString   = _T("Incompatible version of the RPC stub.  RPC_X_WRONG_STUB_VERSION"); break;
        case  1830 :  sTempString   = _T("The RPC pipe object is invalid or corrupted.  RPC_X_INVALID_PIPE_OBJECT"); break;
        case  1831 :  sTempString   = _T("An invalid operation was attempted on an RPC pipe object.  RPC_X_WRONG_PIPE_ORDER"); break;
        case  1832 :  sTempString   = _T("Unsupported RPC pipe version.  RPC_X_WRONG_PIPE_VERSION"); break;
        case  1898 :  sTempString   = _T("The group member was not found.  RPC_S_GROUP_MEMBER_NOT_FOUND"); break;
        case  1899 :  sTempString   = _T("The endpoint mapper database entry could not be created.  EPT_S_CANT_CREATE"); break;
        case  1900 :  sTempString   = _T("The object universal unique identifier (UUID) is the nil UUID.  RPC_S_INVALID_OBJECT"); break;
        case  1901 :  sTempString   = _T("The specified time is invalid.  ERROR_INVALID_TIME"); break;
        case  1902 :  sTempString   = _T("The specified form name is invalid.  ERROR_INVALID_FORM_NAME"); break;
        case  1903 :  sTempString   = _T("The specified form size is invalid.  ERROR_INVALID_FORM_SIZE"); break;
        case  1904 :  sTempString   = _T("The specified printer handle is already being waited on  ERROR_ALREADY_WAITING"); break;
        case  1905 :  sTempString   = _T("The specified printer has been deleted.  ERROR_PRINTER_DELETED"); break;
        case  1906 :  sTempString   = _T("The state of the printer is invalid.  ERROR_INVALID_PRINTER_STATE"); break;
        case  1907 :  sTempString   = _T("The user's password must be changed before logging on the first time.  ERROR_PASSWORD_MUST_CHANGE"); break;
        case  1908 :  sTempString   = _T("Could not find the domain controller for this domain.  ERROR_DOMAIN_CONTROLLER_NOT_FOUND"); break;
        case  1909 :  sTempString   = _T("The referenced account is currently locked out and may not be logged on to.  ERROR_ACCOUNT_LOCKED_OUT"); break;
        case  1910 :  sTempString   = _T("The object exporter specified was not found.  OR_INVALID_OXID"); break;
        case  1911 :  sTempString   = _T("The object specified was not found.  OR_INVALID_OID"); break;
        case  1912 :  sTempString   = _T("The object resolver set specified was not found.  OR_INVALID_SET"); break;
        case  1913 :  sTempString   = _T("Some data remains to be sent in the request buffer.  RPC_S_SEND_INCOMPLETE"); break;
        case  1914 :  sTempString   = _T("Invalid asynchronous remote procedure call handle.  RPC_S_INVALID_ASYNC_HANDLE"); break;
        case  1915 :  sTempString   = _T("Invalid asynchronous RPC call handle for this operation.  RPC_S_INVALID_ASYNC_CALL"); break;
        case  1916 :  sTempString   = _T("The RPC pipe object has already been closed.  RPC_X_PIPE_CLOSED"); break;
        case  1917 :  sTempString   = _T("The RPC call completed before all pipes were processed.  RPC_X_PIPE_DISCIPLINE_ERROR"); break;
        case  1918 :  sTempString   = _T("No more data is available from the RPC pipe.  RPC_X_PIPE_EMPTY"); break;
        case  1919 :  sTempString   = _T("No site name is available for this machine.  ERROR_NO_SITENAME"); break;
        case  1920 :  sTempString   = _T("The file can not be accessed by the system.  ERROR_CANT_ACCESS_FILE"); break;
        case  1921 :  sTempString   = _T("The name of the file cannot be resolved by the system.  ERROR_CANT_RESOLVE_FILENAME"); break;
        case  1922 :  sTempString   = _T("The entry is not of the expected type. RPC_S_ENTRY_TYPE_MISMATCH"); break;
        case  1923 :  sTempString   = _T("Not all object UUIDs could be exported to the specified entry. RPC_S_NOT_ALL_OBJS_EXPORTED"); break;
        case  1924 :  sTempString   = _T("Interface could not be exported to the specified entry. RPC_S_INTERFACE_NOT_EXPORTED"); break;
        case  1925 :  sTempString   = _T("The specified profile entry could not be added. RPC_S_PROFILE_NOT_ADDED"); break;
        case  1926 :  sTempString   = _T("The specified profile element could not be added. RPC_S_PRF_ELT_NOT_ADDED"); break;
        case  1927 :  sTempString   = _T("The specified profile element could not be removed. RPC_S_PRF_ELT_NOT_REMOVED"); break;
        case  1928 :  sTempString   = _T("The group element could not be added. RPC_S_GRP_ELT_NOT_ADDED"); break;
        case  1929 :  sTempString   = _T("The group element could not be removed. RPC_S_GRP_ELT_NOT_REMOVED"); break;
        case  2000 :  sTempString   = _T("The pixel format is invalid.  ERROR_INVALID_PIXEL_FORMAT"); break;
        case  2001 :  sTempString   = _T("The specified driver is invalid.  ERROR_BAD_DRIVER"); break;
        case  2002 :  sTempString   = _T("The window style or class attribute is invalid for this operation.  ERROR_INVALID_WINDOW_STYLE"); break;
        case  2003 :  sTempString   = _T("The requested metafile operation is not supported.  ERROR_METAFILE_NOT_SUPPORTED"); break;
        case  2004 :  sTempString   = _T("The requested transformation operation is not supported.  ERROR_TRANSFORM_NOT_SUPPORTED"); break;
        case  2005 :  sTempString   = _T("The requested clipping operation is not supported.  ERROR_CLIPPING_NOT_SUPPORTED"); break;
        case  2010 :  sTempString   = _T("The specified color management module is invalid.  ERROR_INVALID_CMM"); break;
        case  2011 :  sTempString   = _T("The specified color profile is invalid.  ERROR_INVALID_PROFILE"); break;
        case  2012 :  sTempString   = _T("The specified tag was not found.  ERROR_TAG_NOT_FOUND"); break;
        case  2013 :  sTempString   = _T("A required tag is not present.  ERROR_TAG_NOT_PRESENT"); break;
        case  2014 :  sTempString   = _T("The specified tag is already present.  ERROR_DUPLICATE_TAG"); break;
        case  2015 :  sTempString   = _T("The specified color profile is not associated with any device.  ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE"); break;
        case  2016 :  sTempString   = _T("The specified color profile was not found.  ERROR_PROFILE_NOT_FOUND"); break;
        case  2017 :  sTempString   = _T("The specified color space is invalid.  ERROR_INVALID_COLORSPACE"); break;
        case  2018 :  sTempString   = _T("Image Color Management is not enabled.  ERROR_ICM_NOT_ENABLED"); break;
        case  2019 :  sTempString   = _T("There was an error while deleting the color transform.  ERROR_DELETING_ICM_XFORM"); break;
        case  2020 :  sTempString   = _T("The specified color transform is invalid.  ERROR_INVALID_TRANSFORM"); break;
        case  2021 :  sTempString   = _T("The specified transform does not match the bitmap's color space.  ERROR_COLORSPACE_MISMATCH"); break;
        case  2022 :  sTempString   = _T("The specified named color index is not present in the profile.  ERROR_INVALID_COLORINDEX"); break;
        case  2108 :  sTempString   = _T("The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.  ERROR_CONNECTED_OTHER_PASSWORD"); break;
        case  2202 :  sTempString   = _T("The specified username is invalid.  ERROR_BAD_USERNAME"); break;
        case  2250 :  sTempString   = _T("This network connection does not exist.  ERROR_NOT_CONNECTED"); break;
        case  2401 :  sTempString   = _T("This network connection has files open or requests pending.  ERROR_OPEN_FILES"); break;
        case  2402 :  sTempString   = _T("Active connections still exist.  ERROR_ACTIVE_CONNECTIONS"); break;
        case  2404 :  sTempString   = _T("The device is in use by an active process and cannot be disconnected.  ERROR_DEVICE_IN_USE"); break;
        case  3000 :  sTempString   = _T("The specified print monitor is unknown.  ERROR_UNKNOWN_PRINT_MONITOR"); break;
        case  3001 :  sTempString   = _T("The specified printer driver is currently in use.  ERROR_PRINTER_DRIVER_IN_USE"); break;
        case  3002 :  sTempString   = _T("The spool file was not found.  ERROR_SPOOL_FILE_NOT_FOUND"); break;
        case  3003 :  sTempString   = _T("A StartDocPrinter call was not issued.  ERROR_SPL_NO_STARTDOC"); break;
        case  3004 :  sTempString   = _T("An AddJob call was not issued.  ERROR_SPL_NO_ADDJOB"); break;
        case  3005 :  sTempString   = _T("The specified print processor has already been installed.  ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED"); break;
        case  3006 :  sTempString   = _T("The specified print monitor has already been installed.  ERROR_PRINT_MONITOR_ALREADY_INSTALLED"); break;
        case  3007 :  sTempString   = _T("The specified print monitor does not have the required functions.  ERROR_INVALID_PRINT_MONITOR"); break;
        case  3008 :  sTempString   = _T("The specified print monitor is currently in use.  ERROR_PRINT_MONITOR_IN_USE"); break;
        case  3009 :  sTempString   = _T("The requested operation is not allowed when there are jobs queued to the printer.  ERROR_PRINTER_HAS_JOBS_QUEUED"); break;
        case  3010 :  sTempString   = _T("The requested operation is successful. Changes will not be effective until the system is rebooted.  ERROR_SUCCESS_REBOOT_REQUIRED"); break;
        case  3011 :  sTempString   = _T("The requested operation is successful. Changes will not be effective until the service is restarted.  ERROR_SUCCESS_RESTART_REQUIRED"); break;
        case  3012 :  sTempString   = _T("No printers were found.  ERROR_PRINTER_NOT_FOUND"); break;
        case  4000 :  sTempString   = _T("WINS encountered an error while processing the command.  ERROR_WINS_INTERNAL"); break;
        case  4001 :  sTempString   = _T("The local WINS can not be deleted.  ERROR_CAN_NOT_DEL_LOCAL_WINS"); break;
        case  4002 :  sTempString   = _T("The importation from the file failed.  ERROR_STATIC_INIT"); break;
        case  4003 :  sTempString   = _T("The backup failed. Was a full backup done before?  ERROR_INC_BACKUP"); break;
        case  4004 :  sTempString   = _T("The backup failed. Check the directory to which you are backing the database.  ERROR_FULL_BACKUP"); break;
        case  4005 :  sTempString   = _T("The name does not exist in the WINS database.  ERROR_REC_NON_EXISTENT"); break;
        case  4006 :  sTempString   = _T("Replication with a nonconfigured partner is not allowed.  ERROR_RPL_NOT_ALLOWED"); break;
        case  4100 :  sTempString   = _T("The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.  ERROR_DHCP_ADDRESS_CONFLICT"); break;
        case  4200 :  sTempString   = _T("The GUID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_GUID_NOT_FOUND"); break;
        case  4201 :  sTempString   = _T("The instance name passed was not recognized as valid by a WMI data provider.  ERROR_WMI_INSTANCE_NOT_FOUND"); break;
        case  4202 :  sTempString   = _T("The data item ID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_ITEMID_NOT_FOUND"); break;
        case  4203 :  sTempString   = _T("The WMI request could not be completed and should be retried.  ERROR_WMI_TRY_AGAIN"); break;
        case  4204 :  sTempString   = _T("The WMI data provider could not be located.  ERROR_WMI_DP_NOT_FOUND"); break;
        case  4205 :  sTempString   = _T("The WMI data provider references an instance set that has not been registered.  ERROR_WMI_UNRESOLVED_INSTANCE_REF"); break;
        case  4206 :  sTempString   = _T("The WMI data block or event notification has already been enabled.  ERROR_WMI_ALREADY_ENABLED"); break;
        case  4207 :  sTempString   = _T("The WMI data block is no longer available.  ERROR_WMI_GUID_DISCONNECTED"); break;
        case  4208 :  sTempString   = _T("The WMI data service is not available.  ERROR_WMI_SERVER_UNAVAILABLE"); break;
        case  4209 :  sTempString   = _T("The WMI data provider failed to carry out the request.  ERROR_WMI_DP_FAILED"); break;
        case  4210 :  sTempString   = _T("The WMI MOF information is not valid.  ERROR_WMI_INVALID_MOF"); break;
        case  4211 :  sTempString   = _T("The WMI registration information is not valid.  ERROR_WMI_INVALID_REGINFO"); break;
        case  4212 :  sTempString   = _T("The WMI data block or event notification has already been disabled.  ERROR_WMI_ALREADY_DISABLED"); break;
        case  4213 :  sTempString   = _T("The WMI data item or data block is read only.  ERROR_WMI_READ_ONLY"); break;
        case  4214 :  sTempString   = _T("The WMI data item or data block could not be changed.  ERROR_WMI_SET_FAILURE"); break;
        case  4300 :  sTempString   = _T("The media identifier does not represent a valid medium.  ERROR_INVALID_MEDIA"); break;
        case  4301 :  sTempString   = _T("The library identifier does not represent a valid library.  ERROR_INVALID_LIBRARY"); break;
        case  4302 :  sTempString   = _T("The media pool identifier does not represent a valid media pool.  ERROR_INVALID_MEDIA_POOL"); break;
        case  4303 :  sTempString   = _T("The drive and medium are not compatible or exist in different libraries.  ERROR_DRIVE_MEDIA_MISMATCH"); break;
        case  4304 :  sTempString   = _T("The medium currently exists in an offline library and must be online to perform this operation.  ERROR_MEDIA_OFFLINE"); break;
        case  4305 :  sTempString   = _T("The operation cannot be performed on an offline library.  ERROR_LIBRARY_OFFLINE"); break;
        case  4306 :  sTempString   = _T("The library, drive, or media pool is empty.  ERROR_EMPTY"); break;
        case  4307 :  sTempString   = _T("The library, drive, or media pool must be empty to perform this operation.  ERROR_NOT_EMPTY"); break;
        case  4308 :  sTempString   = _T("No media is currently available in this media pool or library.  ERROR_MEDIA_UNAVAILABLE"); break;
        case  4309 :  sTempString   = _T("A resource required for this operation is disabled.  ERROR_RESOURCE_DISABLED"); break;
        case  4310 :  sTempString   = _T("The media identifier does not represent a valid cleaner.  ERROR_INVALID_CLEANER"); break;
        case  4311 :  sTempString   = _T("The drive cannot be cleaned or does not support cleaning.  ERROR_UNABLE_TO_CLEAN"); break;
        case  4312 :  sTempString   = _T("The object identifier does not represent a valid object.  ERROR_OBJECT_NOT_FOUND"); break;
        case  4313 :  sTempString   = _T("Unable to read from or write to the database.  ERROR_DATABASE_FAILURE"); break;
        case  4314 :  sTempString   = _T("The database is full.  ERROR_DATABASE_FULL"); break;
        case  4315 :  sTempString   = _T("The medium is not compatible with the device or media pool.  ERROR_MEDIA_INCOMPATIBLE"); break;
        case  4316 :  sTempString   = _T("The resource required for this operation does not exist.  ERROR_RESOURCE_NOT_PRESENT"); break;
        case  4317 :  sTempString   = _T("The operation identifier is not valid.  ERROR_INVALID_OPERATION"); break;
        case  4318 :  sTempString   = _T("The media is not mounted or ready for use.  ERROR_MEDIA_NOT_AVAILABLE"); break;
        case  4319 :  sTempString   = _T("The device is not ready for use.  ERROR_DEVICE_NOT_AVAILABLE"); break;
        case  4320 :  sTempString   = _T("The operator or administrator has refused the request.  ERROR_REQUEST_REFUSED"); break;
        case  4321 :  sTempString   = _T("The drive identifier does not represent a valid drive.  ERROR_INVALID_DRIVE_OBJECT"); break;
        case  4322 :  sTempString   = _T("Library is full. No slot is available for use. ERROR_LIBRARY_FULL"); break;
        case  4323 :  sTempString   = _T("The transport cannot access the medium.  ERROR_MEDIUM_NOT_ACCESSIBLE"); break;
        case  4324 :  sTempString   = _T("Unable to load the medium into the drive.  ERROR_UNABLE_TO_LOAD_MEDIUM"); break;
        case  4325 :  sTempString   = _T("Unable to retrieve status about the drive.  ERROR_UNABLE_TO_INVENTORY_DRIVE"); break;
        case  4326 :  sTempString   = _T("Unable to retrieve status about the slot.  ERROR_UNABLE_TO_INVENTORY_SLOT"); break;
        case  4327 :  sTempString   = _T("Unable to retrieve status about the transport.  ERROR_UNABLE_TO_INVENTORY_TRANSPORT"); break;
        case  4328 :  sTempString   = _T("Cannot use the transport because it is already in use.  ERROR_TRANSPORT_FULL"); break;
        case  4329 :  sTempString   = _T("Unable to open or close the inject/eject port.  ERROR_CONTROLLING_IEPORT"); break;
        case  4330 :  sTempString   = _T("Unable to eject the media because it is in a drive.  ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA"); break;
        case  4331 :  sTempString   = _T("A cleaner slot is already reserved.  ERROR_CLEANER_SLOT_SET"); break;
        case  4332 :  sTempString   = _T("A cleaner slot is not reserved.  ERROR_CLEANER_SLOT_NOT_SET"); break;
        case  4333 :  sTempString   = _T("The cleaner cartridge has performed the maximum number of drive cleanings.  ERROR_CLEANER_CARTRIDGE_SPENT"); break;
        case  4334 :  sTempString   = _T("Unexpected on-medium identifier.  ERROR_UNEXPECTED_OMID"); break;
        case  4335 :  sTempString   = _T("The last remaining item in this group or resource cannot be deleted.  ERROR_CANT_DELETE_LAST_ITEM"); break;
        case  4336 :  sTempString   = _T("The message provided exceeds the maximum size allowed for this parameter.  ERROR_MESSAGE_EXCEEDS_MAX_SIZE"); break;
        case  4337 :  sTempString   = _T("The volume contains system or paging files. ERROR_VOLUME_CONTAINS_SYS_FILES"); break;
        case  4338 :  sTempString   = _T("The media type cannot be removed from this library since at least one drive in the library reports it can support this media type. ERROR_INDIGENOUS_TYPE"); break;
        case  4339 :  sTempString   = _T("This offline media cannot be mounted on this system since no enabled drives are present which can be used. ERROR_NO_SUPPORTING_DRIVES"); break;
        case  4350 :  sTempString   = _T("The remote storage service was not able to recall the file.  ERROR_FILE_OFFLINE"); break;
        case  4351 :  sTempString   = _T("The remote storage service is not operational at this time.  ERROR_REMOTE_STORAGE_NOT_ACTIVE"); break;
        case  4352 :  sTempString   = _T("The remote storage service encountered a media error.  ERROR_REMOTE_STORAGE_MEDIA_ERROR"); break;
        case  4390 :  sTempString   = _T("The file or directory is not a reparse point.  ERROR_NOT_A_REPARSE_POINT"); break;
        case  4391 :  sTempString   = _T("The reparse point attribute cannot be set because it conflicts with an existing attribute.  ERROR_REPARSE_ATTRIBUTE_CONFLICT"); break;
        case  4392 :  sTempString   = _T("The data present in the reparse point buffer is invalid.  ERROR_INVALID_REPARSE_DATA"); break;
        case  4393 :  sTempString   = _T("The tag present in the reparse point buffer is invalid. ERROR_REPARSE_TAG_INVALID"); break;
        case  4394 :  sTempString   = _T("There is a mismatch between the tag specified in the request and the tag present in the reparse point. ERROR_REPARSE_TAG_MISMATCH"); break;
        case  4500 :  sTempString   = _T("Single Instance Storage is not available on this volume. ERROR_VOLUME_NOT_SIS_ENABLED"); break;
        case  5001 :  sTempString   = _T("The cluster resource cannot be moved to another group because other resources are dependent on it.  ERROR_DEPENDENT_RESOURCE_EXISTS"); break;
        case  5002 :  sTempString   = _T("The cluster resource dependency cannot be found.  ERROR_DEPENDENCY_NOT_FOUND"); break;
        case  5003 :  sTempString   = _T("The cluster resource cannot be made dependent on the specified resource because it is already dependent.  ERROR_DEPENDENCY_ALREADY_EXISTS"); break;
        case  5004 :  sTempString   = _T("The cluster resource is not online.  ERROR_RESOURCE_NOT_ONLINE"); break;
        case  5005 :  sTempString   = _T("A cluster node is not available for this operation.  ERROR_HOST_NODE_NOT_AVAILABLE"); break;
        case  5006 :  sTempString   = _T("The cluster resource is not available.  ERROR_RESOURCE_NOT_AVAILABLE"); break;
        case  5007 :  sTempString   = _T("The cluster resource could not be found.  ERROR_RESOURCE_NOT_FOUND"); break;
        case  5008 :  sTempString   = _T("The cluster is being shut down.  ERROR_SHUTDOWN_CLUSTER"); break;
        case  5009 :  sTempString   = _T("A cluster node cannot be evicted from the cluster while it is online.  ERROR_CANT_EVICT_ACTIVE_NODE"); break;
        case  5010 :  sTempString   = _T("The object already exists.  ERROR_OBJECT_ALREADY_EXISTS"); break;
        case  5011 :  sTempString   = _T("The object is already in the list.  ERROR_OBJECT_IN_LIST"); break;
        case  5012 :  sTempString   = _T("The cluster group is not available for any new requests.  ERROR_GROUP_NOT_AVAILABLE"); break;
        case  5013 :  sTempString   = _T("The cluster group could not be found.  ERROR_GROUP_NOT_FOUND"); break;
        case  5014 :  sTempString   = _T("The operation could not be completed because the cluster group is not online.  ERROR_GROUP_NOT_ONLINE"); break;
        case  5015 :  sTempString   = _T("The cluster node is not the owner of the resource.  ERROR_HOST_NODE_NOT_RESOURCE_OWNER"); break;
        case  5016 :  sTempString   = _T("The cluster node is not the owner of the group.  ERROR_HOST_NODE_NOT_GROUP_OWNER"); break;
        case  5017 :  sTempString   = _T("The cluster resource could not be created in the specified resource monitor.  ERROR_RESMON_CREATE_FAILED"); break;
        case  5018 :  sTempString   = _T("The cluster resource could not be brought online by the resource monitor.  ERROR_RESMON_ONLINE_FAILED"); break;
        case  5019 :  sTempString   = _T("The operation could not be completed because the cluster resource is online.  ERROR_RESOURCE_ONLINE"); break;
        case  5020 :  sTempString   = _T("The cluster resource could not be deleted or brought offline because it is the quorum resource.  ERROR_QUORUM_RESOURCE"); break;
        case  5021 :  sTempString   = _T("The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.  ERROR_NOT_QUORUM_CAPABLE"); break;
        case  5022 :  sTempString   = _T("The cluster software is shutting down.  ERROR_CLUSTER_SHUTTING_DOWN"); break;
        case  5023 :  sTempString   = _T("The group or resource is not in the correct state to perform the requested operation.  ERROR_INVALID_STATE"); break;
        case  5024 :  sTempString   = _T("The properties were stored but not all changes will take effect until the next time the resource is brought online.  ERROR_RESOURCE_PROPERTIES_STORED"); break;
        case  5025 :  sTempString   = _T("The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.  ERROR_NOT_QUORUM_CLASS"); break;
        case  5026 :  sTempString   = _T("The cluster resource could not be deleted since it is a core resource.  ERROR_CORE_RESOURCE"); break;
        case  5027 :  sTempString   = _T("The quorum resource failed to come online.  ERROR_QUORUM_RESOURCE_ONLINE_FAILED"); break;
        case  5028 :  sTempString   = _T("The quorum log could not be created or mounted successfully.  ERROR_QUORUMLOG_OPEN_FAILED"); break;
        case  5029 :  sTempString   = _T("The cluster log is corrupt.  ERROR_CLUSTERLOG_CORRUPT"); break;
        case  5030 :  sTempString   = _T("The record could not be written to the cluster log since it exceeds the maximum size.  ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE"); break;
        case  5031 :  sTempString   = _T("The cluster log exceeds its maximum size.  ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE"); break;
        case  5032 :  sTempString   = _T("No checkpoint record was found in the cluster log.  ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND"); break;
        case  5033 :  sTempString   = _T("The minimum required disk space needed for logging is not available.  ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE"); break;
        case  5034 :  sTempString   = _T("The cluster node failed to take control of the quorum resource because the resource is owned by another active node. ERROR_QUORUM_OWNER_ALIVE"); break;
        case  5035 :  sTempString   = _T("A cluster network is not available for this operation. ERROR_NETWORK_NOT_AVAILABLE"); break;
        case  5036 :  sTempString   = _T("A cluster node is not available for this operation. ERROR_NODE_NOT_AVAILABLE"); break;
        case  5037 :  sTempString   = _T("All cluster nodes must be running to perform this operation. ERROR_ALL_NODES_NOT_AVAILABLE"); break;
        case  5038 :  sTempString   = _T("A cluster resource failed. ERROR_RESOURCE_FAILED"); break;
        case  5039 :  sTempString   = _T("The cluster node is not valid. ERROR_CLUSTER_INVALID_NODE"); break;
        case  5040 :  sTempString   = _T("The cluster node already exists. ERROR_CLUSTER_NODE_EXISTS"); break;
        case  5041 :  sTempString   = _T("A node is in the process of joining the cluster. ERROR_CLUSTER_JOIN_IN_PROGRESS"); break;
        case  5042 :  sTempString   = _T("The cluster node was not found. ERROR_CLUSTER_NODE_NOT_FOUND"); break;
        case  5043 :  sTempString   = _T("The cluster local node information was not found. ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND"); break;
        case  5044 :  sTempString   = _T("The cluster network already exists. ERROR_CLUSTER_NETWORK_EXISTS"); break;
        case  5045 :  sTempString   = _T("The cluster network was not found. ERROR_CLUSTER_NETWORK_NOT_FOUND"); break;
        case  5046 :  sTempString   = _T("The cluster network interface already exists. ERROR_CLUSTER_NETINTERFACE_EXISTS"); break;
        case  5047 :  sTempString   = _T("The cluster network interface was not found. ERROR_CLUSTER_NETINTERFACE_NOT_FOUND"); break;
        case  5048 :  sTempString   = _T("The cluster request is not valid for this object. ERROR_CLUSTER_INVALID_REQUEST"); break;
        case  5049 :  sTempString   = _T("The cluster network provider is not valid. ERROR_CLUSTER_INVALID_NETWORK_PROVIDER"); break;
        case  5050 :  sTempString   = _T("The cluster node is down. ERROR_CLUSTER_NODE_DOWN"); break;
        case  5051 :  sTempString   = _T("The cluster node is not reachable. ERROR_CLUSTER_NODE_UNREACHABLE"); break;
        case  5052 :  sTempString   = _T("The cluster node is not a member of the cluster. ERROR_CLUSTER_NODE_NOT_MEMBER"); break;
        case  5053 :  sTempString   = _T("A cluster join operation is not in progress. ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS"); break;
        case  5054 :  sTempString   = _T("The cluster network is not valid. ERROR_CLUSTER_INVALID_NETWORK"); break;
        case  5056 :  sTempString   = _T("The cluster node is up. ERROR_CLUSTER_NODE_UP"); break;
        case  5057 :  sTempString   = _T("The cluster IP address is already in use. ERROR_CLUSTER_IPADDR_IN_USE"); break;
        case  5058 :  sTempString   = _T("The cluster node is not paused. ERROR_CLUSTER_NODE_NOT_PAUSED"); break;
        case  5059 :  sTempString   = _T("No cluster security context is available. ERROR_CLUSTER_NO_SECURITY_CONTEXT"); break;
        case  5060 :  sTempString   = _T("The cluster network is not configured for internal cluster communication. ERROR_CLUSTER_NETWORK_NOT_INTERNAL"); break;
        case  5061 :  sTempString   = _T("The cluster node is already up. ERROR_CLUSTER_NODE_ALREADY_UP"); break;
        case  5062 :  sTempString   = _T("The cluster node is already down. ERROR_CLUSTER_NODE_ALREADY_DOWN"); break;
        case  5063 :  sTempString   = _T("The cluster network is already online. ERROR_CLUSTER_NETWORK_ALREADY_ONLINE"); break;
        case  5064 :  sTempString   = _T("The cluster network is already offline. ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE"); break;
        case  5065 :  sTempString   = _T("The cluster node is already a member of the cluster. ERROR_CLUSTER_NODE_ALREADY_MEMBER"); break;
        case  5066 :  sTempString   = _T("The cluster network is the only one configured for internal cluster communication between two or more active cluster nodes. The internal communication capability cannot be removed from the network. ERROR_CLUSTER_LAST_INTERNAL_NETWORK"); break;
        case  5067 :  sTempString   = _T("One or more cluster resources depend on the network to provide service to clients. The client access capability cannot be removed from the network. ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS"); break;
        case  5068 :  sTempString   = _T("This operation cannot be performed on the cluster resource as it the quorum resource. You may not bring the quorum resource offline or modify its possible owners list. ERROR_INVALID_OPERATION_ON_QUORUM"); break;
        case  5069 :  sTempString   = _T("The cluster quorum resource is not allowed to have any dependencies. ERROR_DEPENDENCY_NOT_ALLOWED"); break;
        case  5070 :  sTempString   = _T("The cluster node is paused. ERROR_CLUSTER_NODE_PAUSED"); break;
        case  5071 :  sTempString   = _T("The cluster resource cannot be brought online. The owner node cannot run this resource. ERROR_NODE_CANT_HOST_RESOURCE"); break;
        case  5072 :  sTempString   = _T("The cluster node is not ready to perform the requested operation. ERROR_CLUSTER_NODE_NOT_READY"); break;
        case  5073 :  sTempString   = _T("The cluster node is shutting down. ERROR_CLUSTER_NODE_SHUTTING_DOWN"); break;
        case  5074 :  sTempString   = _T("The cluster join operation was aborted. ERROR_CLUSTER_JOIN_ABORTED"); break;
        case  5075 :  sTempString   = _T("The cluster join operation failed due to incompatible software versions between the joining node and its sponsor. ERROR_CLUSTER_INCOMPATIBLE_VERSIONS"); break;
        case  5076 :  sTempString   = _T("This resource cannot be created because the cluster has reached the limit on the number of resources it can monitor. ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED"); break;
        case  5077 :  sTempString   = _T("The system configuration changed during the cluster join or form operation. The join or form operation was aborted. ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED"); break;
        case  5078 :  sTempString   = _T("The specified resource type was not found. ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND"); break;
        case  5079 :  sTempString   = _T("The specified node does not support a resource of this type. This may be due to version inconsistencies or due to the absence of the resource DLL on this node. ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED"); break;
        case  5080 :  sTempString   = _T("The specified resource name is supported by this resource DLL. This may be due to a bad (or changed) name supplied to the resource DLL. ERROR_CLUSTER_RESNAME_NOT_FOUND"); break;
        case  5081 :  sTempString   = _T("No authentication package could be registered with the RPC server. ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED"); break;
        case  5082 :  sTempString   = _T("You cannot bring the group online because the owner of the group is not in the preferred list for the group. To change the owner node for the group, move the group. ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST"); break;
        case  5083 :  sTempString   = _T("The join operation failed because the cluster database sequence number has changed or is incompatible with the locker node. This may happen during a join operation if the cluster database was changing during the join. ERROR_CLUSTER_DATABASE_SEQMISMATCH"); break;
        case  5084 :  sTempString   = _T("The resource monitor will not allow the fail operation to be performed while the resource is in its current state. This may happen if the resource is in a pending state. ERROR_RESMON_INVALID_STATE"); break;
        case  5085 :  sTempString   = _T("A non locker code got a request to reserve the lock for making global updates. ERROR_CLUSTER_GUM_NOT_LOCKER"); break;
        case  5086 :  sTempString   = _T("The quorum disk could not be located by the cluster service. ERROR_QUORUM_DISK_NOT_FOUND"); break;
        case  5087 :  sTempString   = _T("The backup up cluster database is possibly corrupt. ERROR_DATABASE_BACKUP_CORRUPT"); break;
        case  5088 :  sTempString   = _T("A DFS root already exists in this cluster node. ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT"); break;
        case  5089 :  sTempString   = _T("An attempt to modify a resource property failed because it conflicts with another existing property. ERROR_RESOURCE_PROPERTY_UNCHANGEABLE"); break;
        case  6000 :  sTempString   = _T("The specified file could not be encrypted.  ERROR_ENCRYPTION_FAILED"); break;
        case  6001 :  sTempString   = _T("The specified file could not be decrypted.  ERROR_DECRYPTION_FAILED"); break;
        case  6002 :  sTempString   = _T("The specified file is encrypted and the user does not have the ability to decrypt it.  ERROR_FILE_ENCRYPTED"); break;
        case  6003 :  sTempString   = _T("There is no valid encryption recovery policy configured for this system.  ERROR_NO_RECOVERY_POLICY"); break;
        case  6004 :  sTempString   = _T("The required encryption driver is not loaded for this system.  ERROR_NO_EFS"); break;
        case  6005 :  sTempString   = _T("The file was encrypted with a different encryption driver than is currently loaded.  ERROR_WRONG_EFS"); break;
        case  6006 :  sTempString   = _T("There are no EFS keys defined for the user.  ERROR_NO_USER_KEYS"); break;
        case  6007 :  sTempString   = _T("The specified file is not encrypted.  ERROR_FILE_NOT_ENCRYPTED"); break;
        case  6008 :  sTempString   = _T("The specified file is not in the defined EFS export format.  ERROR_NOT_EXPORT_FORMAT"); break;
        case  6009 :  sTempString   = _T("The specified file is read only. ERROR_FILE_READ_ONLY"); break;
        case  6010 :  sTempString   = _T("The directory has been disabled for encryption. ERROR_DIR_EFS_DISALLOWED"); break;
        case  6011 :  sTempString   = _T("The server is not trusted for remote encryption operation. ERROR_EFS_SERVER_NOT_TRUSTED"); break;
        case  6118 :  sTempString   = _T("The list of servers for this workgroup is not currently available.  ERROR_NO_BROWSER_SERVERS_FOUND"); break;
        case  6200 :  sTempString   = _T("The Task Scheduler service must be configured to run in the System account to function properly. Individual tasks may be configured to run in other accounts.  SCHED_E_SERVICE_NOT_LOCALSYSTEM"); break;
        case  7001 :  sTempString   = _T("The specified session name is invalid.  ERROR_CTX_WINSTATION_NAME_INVALID"); break;
        case  7002 :  sTempString   = _T("The specified protocol driver is invalid.  ERROR_CTX_INVALID_PD"); break;
        case  7003 :  sTempString   = _T("The specified protocol driver was not found in the system path.  ERROR_CTX_PD_NOT_FOUND"); break;
        case  7004 :  sTempString   = _T("The specified terminal connection driver was not found in the system path.  ERROR_CTX_WD_NOT_FOUND"); break;
        case  7005 :  sTempString   = _T("A registry key for event logging could not be created for this session.  ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY"); break;
        case  7006 :  sTempString   = _T("A service with the same name already exists on the system.  ERROR_CTX_SERVICE_NAME_COLLISION"); break;
        case  7007 :  sTempString   = _T("A close operation is pending on the session.  ERROR_CTX_CLOSE_PENDING"); break;
        case  7008 :  sTempString   = _T("There are no free output buffers available.  ERROR_CTX_NO_OUTBUF"); break;
        case  7009 :  sTempString   = _T("The MODEM.INF file was not found.  ERROR_CTX_MODEM_INF_NOT_FOUND"); break;
        case  7010 :  sTempString   = _T("The modem name was not found in MODEM.INF.  ERROR_CTX_INVALID_MODEMNAME"); break;
        case  7011 :  sTempString   = _T("The modem did not accept the command sent to it. Verify that the configured modem name matches the attached modem.  ERROR_CTX_MODEM_RESPONSE_ERROR"); break;
        case  7012 :  sTempString   = _T("The modem did not respond to the command sent to it. Verify that the modem is properly cabled and powered on.  ERROR_CTX_MODEM_RESPONSE_TIMEOUT"); break;
        case  7013 :  sTempString   = _T("Carrier detect has failed or carrier has been dropped due to disconnect.  ERROR_CTX_MODEM_RESPONSE_NO_CARRIER"); break;
        case  7014 :  sTempString   = _T("Dial tone not detected within the required time. Verify that the phone cable is properly attached and functional.  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE"); break;
        case  7015 :  sTempString   = _T("Busy signal detected at remote site on callback.  ERROR_CTX_MODEM_RESPONSE_BUSY"); break;
        case  7016 :  sTempString   = _T("Voice detected at remote site on callback.  ERROR_CTX_MODEM_RESPONSE_VOICE"); break;
        case  7017 :  sTempString   = _T("Transport driver error  ERROR_CTX_TD_ERROR"); break;
        case  7022 :  sTempString   = _T("The specified session cannot be found.  ERROR_CTX_WINSTATION_NOT_FOUND"); break;
        case  7023 :  sTempString   = _T("The specified session name is already in use.  ERROR_CTX_WINSTATION_ALREADY_EXISTS"); break;
        case  7024 :  sTempString   = _T("The requested operation cannot be completed because the terminal connection is currently busy processing a connect, disconnect, reset, or delete operation.  ERROR_CTX_WINSTATION_BUSY"); break;
        case  7025 :  sTempString   = _T("An attempt has been made to connect to a session whose video mode is not supported by the current client.  ERROR_CTX_BAD_VIDEO_MODE"); break;
        case  7035 :  sTempString   = _T("The application attempted to enable DOS graphics mode. DOS graphics mode is not supported.  ERROR_CTX_GRAPHICS_INVALID"); break;
        case  7037 :  sTempString   = _T("Your interactive logon privilege has been disabled. Please contact your administrator.  ERROR_CTX_LOGON_DISABLED"); break;
        case  7038 :  sTempString   = _T("The requested operation can be performed only on the system console. This is most often the result of a driver or system DLL requiring direct console access.  ERROR_CTX_NOT_CONSOLE"); break;
        case  7040 :  sTempString   = _T("The client failed to respond to the server connect message.  ERROR_CTX_CLIENT_QUERY_TIMEOUT"); break;
        case  7041 :  sTempString   = _T("Disconnecting the console session is not supported.  ERROR_CTX_CONSOLE_DISCONNECT"); break;
        case  7042 :  sTempString   = _T("Reconnecting a disconnected session to the console is not supported.  ERROR_CTX_CONSOLE_CONNECT"); break;
        case  7044 :  sTempString   = _T("The request to control another session remotely was denied.  ERROR_CTX_SHADOW_DENIED"); break;
        case  7045 :  sTempString   = _T("The requested session access is denied.  ERROR_CTX_WINSTATION_ACCESS_DENIED"); break;
        case  7049 :  sTempString   = _T("The specified terminal connection driver is invalid.  ERROR_CTX_INVALID_WD"); break;
        case  7050 :  sTempString   = _T("The requested session cannot be controlled remotely. This may be because the session is disconnected or does not currently have a user logged on. Also, you cannot control a session remotely from the system console or control the system console remotely .  ERROR_CTX_SHADOW_INVALID"); break;
        case  7051 :  sTempString   = _T("The requested session is not configured to allow remote control.  ERROR_CTX_SHADOW_DISABLED"); break;
        case  7052 :  sTempString   = _T("Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number is currently being used by another user. Please call your system administrator to obtain a new copy of the Terminal Server client with a valid, unique license number. ERROR_CTX_CLIENT_LICENSE_IN_USE"); break;
        case  7053 :  sTempString   = _T("Your request to connect to this Terminal Server has been rejected. Your Terminal Server client license number has not been entered for this copy of the Terminal Server client. Please call your system administrator for help in entering a valid, unique license number for this Terminal Server client. ERROR_CTX_CLIENT_LICENSE_NOT_SET"); break;
        case  7054 :  sTempString   = _T("The system has reached its licensed logon limit. Please try again later. ERROR_CTX_LICENSE_NOT_AVAILABLE"); break;
        case  7055 :  sTempString   = _T("The client you are using is not licensed to use this system. Your logon request is denied. ERROR_CTX_LICENSE_CLIENT_INVALID"); break;
        case  7056 :  sTempString   = _T("The system license has expired. Your logon request is denied. ERROR_CTX_LICENSE_EXPIRED"); break;
        case  8001 :  sTempString   = _T("The file replication service API was called incorrectly.  FRS_ERR_INVALID_API_SEQUENCE"); break;
        case  8002 :  sTempString   = _T("The file replication service cannot be started.  FRS_ERR_STARTING_SERVICE"); break;
        case  8003 :  sTempString   = _T("The file replication service cannot be stopped.  FRS_ERR_STOPPING_SERVICE"); break;
        case  8004 :  sTempString   = _T("The file replication service API terminated the request. The event log may have more information.  FRS_ERR_INTERNAL_API"); break;
        case  8005 :  sTempString   = _T("The file replication service terminated the request. The event log may have more information.  FRS_ERR_INTERNAL"); break;
        case  8006 :  sTempString   = _T("The file replication service cannot be contacted. The event log may have more information.  FRS_ERR_SERVICE_COMM"); break;
        case  8007 :  sTempString   = _T("The file replication service cannot satisfy the request because the user has insufficient privileges. The event log may have more information.  FRS_ERR_INSUFFICIENT_PRIV"); break;
        case  8008 :  sTempString   = _T("The file replication service cannot satisfy the request because authenticated RPC is not available. The event log may have more information.  FRS_ERR_AUTHENTICATION"); break;
        case  8009 :  sTempString   = _T("The file replication service cannot satisfy the request because the user has insufficient privileges on the domain controller. The event log may have more information.  FRS_ERR_PARENT_INSUFFICIENT_PRIV"); break;
        case  8010 :  sTempString   = _T("The file replication service cannot satisfy the request because authenticated RPC is not available on the domain controller. The event log may have more information.  FRS_ERR_PARENT_AUTHENTICATION"); break;
        case  8011 :  sTempString   = _T("The file replication service cannot communicate with the file replication service on the domain controller. The event log may have more information.  FRS_ERR_CHILD_TO_PARENT_COMM"); break;
        case  8012 :  sTempString   = _T("The file replication service on the domain controller cannot communicate with the file replication service on this computer. The event log may have more information.  FRS_ERR_PARENT_TO_CHILD_COMM"); break;
        case  8013 :  sTempString   = _T("The file replication service cannot populate the system volume because of an internal error. The event log may have more information.  FRS_ERR_SYSVOL_POPULATE"); break;
        case  8014 :  sTempString   = _T("The file replication service cannot populate the system volume because of an internal timeout. The event log may have more information.  FRS_ERR_SYSVOL_POPULATE_TIMEOUT"); break;
        case  8015 :  sTempString   = _T("The file replication service cannot process the request. The system volume is busy with a previous request.  FRS_ERR_SYSVOL_IS_BUSY"); break;
        case  8016 :  sTempString   = _T("The file replication service cannot stop replicating the system volume because of an internal error. The event log may have more information.  FRS_ERR_SYSVOL_DEMOTE"); break;
        case  8017 :  sTempString   = _T("The file replication service detected an invalid parameter.  FRS_ERR_INVALID_SERVICE_PARAMETER"); break;
        case  8200 :  sTempString   = _T("An error occurred while installing the directory service. For more information, see the event log.  ERROR_DS_NOT_INSTALLED"); break;
        case  8201 :  sTempString   = _T("The directory service evaluated group memberships locally.  ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY"); break;
        case  8202 :  sTempString   = _T("The specified directory service attribute or value does not exist.  ERROR_DS_NO_ATTRIBUTE_OR_VALUE"); break;
        case  8203 :  sTempString   = _T("The attribute syntax specified to the directory service is invalid.  ERROR_DS_INVALID_ATTRIBUTE_SYNTAX"); break;
        case  8204 :  sTempString   = _T("The attribute type specified to the directory service is not defined.  ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED"); break;
        case  8205 :  sTempString   = _T("The specified directory service attribute or value already exists.  ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS"); break;
        case  8206 :  sTempString   = _T("The directory service is busy.  ERROR_DS_BUSY"); break;
        case  8207 :  sTempString   = _T("The directory service is unavailable.  ERROR_DS_UNAVAILABLE"); break;
        case  8208 :  sTempString   = _T("The directory service was unable to allocate a relative identifier.  ERROR_DS_NO_RIDS_ALLOCATED"); break;
        case  8209 :  sTempString   = _T("The directory service has exhausted the pool of relative identifiers.  ERROR_DS_NO_MORE_RIDS"); break;
        case  8210 :  sTempString   = _T("The requested operation could not be performed because the directory service is not the master for that type of operation.  ERROR_DS_INCORRECT_ROLE_OWNER"); break;
        case  8211 :  sTempString   = _T("The directory service was unable to initialize the subsystem that allocates relative identifiers.  ERROR_DS_RIDMGR_INIT_ERROR"); break;
        case  8212 :  sTempString   = _T("The requested operation did not satisfy one or more constraints associated with the class of the object.  ERROR_DS_OBJ_CLASS_VIOLATION"); break;
        case  8213 :  sTempString   = _T("The directory service can perform the requested operation only on a leaf object.  ERROR_DS_CANT_ON_NON_LEAF"); break;
        case  8214 :  sTempString   = _T("The directory service cannot perform the requested operation on the RDN attribute of an object.  ERROR_DS_CANT_ON_RDN"); break;
        case  8215 :  sTempString   = _T("The directory service detected an attempt to modify the object class of an object.  ERROR_DS_CANT_MOD_OBJ_CLASS"); break;
        case  8216 :  sTempString   = _T("The requested cross-domain move operation could not be performed.  ERROR_DS_CROSS_DOM_MOVE_ERROR"); break;
        case  8217 :  sTempString   = _T("Unable to contact the global catalog server.  ERROR_DS_GC_NOT_AVAILABLE"); break;
        case  8218 :  sTempString   = _T("The policy object is shared and can only be modified at the root.  ERROR_SHARED_POLICY"); break;
        case  8219 :  sTempString   = _T("The policy object does not exist.  ERROR_POLICY_OBJECT_NOT_FOUND"); break;
        case  8220 :  sTempString   = _T("The requested policy information is only in the directory service.  ERROR_POLICY_ONLY_IN_DS"); break;
        case  8221 :  sTempString   = _T("A domain controller promotion is currently active.  ERROR_PROMOTION_ACTIVE"); break;
        case  8222 :  sTempString   = _T("A domain controller promotion is not currently active  ERROR_NO_PROMOTION_ACTIVE"); break;
        case  8224 :  sTempString   = _T("An operations error occurred.  ERROR_DS_OPERATIONS_ERROR"); break;
        case  8225 :  sTempString   = _T("A protocol error occurred.  ERROR_DS_PROTOCOL_ERROR"); break;
        case  8226 :  sTempString   = _T("The time limit for this request was exceeded.  ERROR_DS_TIMELIMIT_EXCEEDED"); break;
        case  8227 :  sTempString   = _T("The size limit for this request was exceeded.  ERROR_DS_SIZELIMIT_EXCEEDED"); break;
        case  8228 :  sTempString   = _T("The administrative limit for this request was exceeded.  ERROR_DS_ADMIN_LIMIT_EXCEEDED"); break;
        case  8229 :  sTempString   = _T("The compare response was false.  ERROR_DS_COMPARE_FALSE"); break;
        case  8230 :  sTempString   = _T("The compare response was true.  ERROR_DS_COMPARE_TRUE"); break;
        case  8231 :  sTempString   = _T("The requested authentication method is not supported by the server.  ERROR_DS_AUTH_METHOD_NOT_SUPPORTED"); break;
        case  8232 :  sTempString   = _T("A more secure authentication method is required for this server.  ERROR_DS_STRONG_AUTH_REQUIRED"); break;
        case  8233 :  sTempString   = _T("Inappropriate authentication.  ERROR_DS_INAPPROPRIATE_AUTH"); break;
        case  8234 :  sTempString   = _T("The authentication mechanism is unknown.  ERROR_DS_AUTH_UNKNOWN"); break;
        case  8235 :  sTempString   = _T("A referral was returned from the server.  ERROR_DS_REFERRAL"); break;
        case  8236 :  sTempString   = _T("The server does not support the requested critical extension.  ERROR_DS_UNAVAILABLE_CRIT_EXTENSION"); break;
        case  8237 :  sTempString   = _T("This request requires a secure connection.  ERROR_DS_CONFIDENTIALITY_REQUIRED"); break;
        case  8238 :  sTempString   = _T("Inappropriate matching.  ERROR_DS_INAPPROPRIATE_MATCHING"); break;
        case  8239 :  sTempString   = _T("A constraint violation occurred.  ERROR_DS_CONSTRAINT_VIOLATION"); break;
        case  8240 :  sTempString   = _T("There is no such object on the server.  ERROR_DS_NO_SUCH_OBJECT"); break;
        case  8241 :  sTempString   = _T("There is an alias problem.  ERROR_DS_ALIAS_PROBLEM"); break;
        case  8242 :  sTempString   = _T("An invalid dn syntax has been specified.  ERROR_DS_INVALID_DN_SYNTAX"); break;
        case  8243 :  sTempString   = _T("The object is a leaf object.  ERROR_DS_IS_LEAF"); break;
        case  8244 :  sTempString   = _T("There is an alias dereferencing problem.  ERROR_DS_ALIAS_DEREF_PROBLEM"); break;
        case  8245 :  sTempString   = _T("The server is unwilling to process the request.  ERROR_DS_UNWILLING_TO_PERFORM"); break;
        case  8246 :  sTempString   = _T("A loop has been detected.  ERROR_DS_LOOP_DETECT"); break;
        case  8247 :  sTempString   = _T("There is a naming violation.  ERROR_DS_NAMING_VIOLATION"); break;
        case  8248 :  sTempString   = _T("The result set is too large.  ERROR_DS_OBJECT_RESULTS_TOO_LARGE"); break;
        case  8249 :  sTempString   = _T("The operation affects multiple DSAs  ERROR_DS_AFFECTS_MULTIPLE_DSAS"); break;
        case  8250 :  sTempString   = _T("The server is not operational.  ERROR_DS_SERVER_DOWN"); break;
        case  8251 :  sTempString   = _T("A local error has occurred.  ERROR_DS_LOCAL_ERROR"); break;
        case  8252 :  sTempString   = _T("An encoding error has occurred.  ERROR_DS_ENCODING_ERROR"); break;
        case  8253 :  sTempString   = _T("A decoding error has occurred.  ERROR_DS_DECODING_ERROR"); break;
        case  8254 :  sTempString   = _T("The search filter cannot be recognized.  ERROR_DS_FILTER_UNKNOWN"); break;
        case  8255 :  sTempString   = _T("One or more parameters are illegal.  ERROR_DS_PARAM_ERROR"); break;
        case  8256 :  sTempString   = _T("The specified method is not supported.  ERROR_DS_NOT_SUPPORTED"); break;
        case  8257 :  sTempString   = _T("No results were returned.  ERROR_DS_NO_RESULTS_RETURNED"); break;
        case  8258 :  sTempString   = _T("The specified control is not supported by the server.  ERROR_DS_CONTROL_NOT_FOUND"); break;
        case  8259 :  sTempString   = _T("A referral loop was detected by the client.  ERROR_DS_CLIENT_LOOP"); break;
        case  8260 :  sTempString   = _T("The preset referral limit was exceeded.  ERROR_DS_REFERRAL_LIMIT_EXCEEDED"); break;
        case  8301 :  sTempString   = _T("The root object must be the head of a naming context. The root object cannot have an instantiated parent.  ERROR_DS_ROOT_MUST_BE_NC"); break;
        case  8302 :  sTempString   = _T("The add replica operation cannot be performed. The naming context must be writable in order to create the replica.  ERROR_DS_ADD_REPLICA_INHIBITED"); break;
        case  8303 :  sTempString   = _T("A reference to an attribute that is not defined in the schema occurred.  ERROR_DS_ATT_NOT_DEF_IN_SCHEMA"); break;
        case  8304 :  sTempString   = _T("The maximum size of an object has been exceeded.  ERROR_DS_MAX_OBJ_SIZE_EXCEEDED"); break;
        case  8305 :  sTempString   = _T("An attempt was made to add an object to the directory with a name that is already in use.  ERROR_DS_OBJ_STRING_NAME_EXISTS"); break;
        case  8306 :  sTempString   = _T("An attempt was made to add an object of a class that does not have an RDN defined in the schema.  ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA"); break;
        case  8307 :  sTempString   = _T("An attempt was made to add an object using an RDN that is not the RDN defined in the schema.  ERROR_DS_RDN_DOESNT_MATCH_SCHEMA"); break;
        case  8308 :  sTempString   = _T("None of the requested attributes were found on the objects.  ERROR_DS_NO_REQUESTED_ATTS_FOUND"); break;
        case  8309 :  sTempString   = _T("The user buffer is too small.  ERROR_DS_USER_BUFFER_TO_SMALL"); break;
        case  8310 :  sTempString   = _T("The attribute specified in the operation is not present on the object.  ERROR_DS_ATT_IS_NOT_ON_OBJ"); break;
        case  8311 :  sTempString   = _T("Illegal modify operation. Some aspect of the modification is not permitted.  ERROR_DS_ILLEGAL_MOD_OPERATION"); break;
        case  8312 :  sTempString   = _T("The specified object is too large.  ERROR_DS_OBJ_TOO_LARGE"); break;
        case  8313 :  sTempString   = _T("The specified instance type is not valid.  ERROR_DS_BAD_INSTANCE_TYPE"); break;
        case  8314 :  sTempString   = _T("The operation must be performed at a master DSA. ERROR_DS_MASTERDSA_REQUIRED"); break;
        case  8315 :  sTempString   = _T("The object class attribute must be specified. ERROR_DS_OBJECT_CLASS_REQUIRED"); break;
        case  8316 :  sTempString   = _T("A required attribute is missing. ERROR_DS_MISSING_REQUIRED_ATT"); break;
        case  8317 :  sTempString   = _T("An attempt was made to modify an object to include an attribute that is not legal for its class  ERROR_DS_ATT_NOT_DEF_FOR_CLASS"); break;
        case  8318 :  sTempString   = _T("The specified attribute is already present on the object. ERROR_DS_ATT_ALREADY_EXISTS"); break;
        case  8320 :  sTempString   = _T("The specified attribute is not present, or has no values. ERROR_DS_CANT_ADD_ATT_VALUES"); break;
        case  8321 :  sTempString   = _T("Multiple values were specified for an attribute that can have only one value. ERROR_DS_SINGLE_VALUE_CONSTRAINT"); break;
        case  8322 :  sTempString   = _T("A value for the attribute was not in the acceptable range of values. ERROR_DS_RANGE_CONSTRAINT"); break;
        case  8323 :  sTempString   = _T("The specified value already exists. ERROR_DS_ATT_VAL_ALREADY_EXISTS"); break;
        case  8324 :  sTempString   = _T("The attribute cannot be removed because it is not present on the object. ERROR_DS_CANT_REM_MISSING_ATT"); break;
        case  8325 :  sTempString   = _T("The attribute value cannot be removed because it is not present on the object. ERROR_DS_CANT_REM_MISSING_ATT_VAL"); break;
        case  8326 :  sTempString   = _T("The specified root object cannot be a subref. ERROR_DS_ROOT_CANT_BE_SUBREF"); break;
        case  8327 :  sTempString   = _T("Chaining is not permitted. ERROR_DS_NO_CHAINING"); break;
        case  8328 :  sTempString   = _T("Chained evaluation is not permitted. ERROR_DS_NO_CHAINED_EVAL"); break;
        case  8329 :  sTempString   = _T("The operation could not be performed because the object's parent is either uninstantiated or deleted. ERROR_DS_NO_PARENT_OBJECT"); break;
        case  8330 :  sTempString   = _T("Having a parent that is an alias is not permitted. Aliases are leaf objects. ERROR_DS_PARENT_IS_AN_ALIAS"); break;
        case  8331 :  sTempString   = _T("The object and parent must be of the same type, either both masters or both replicas.  ERROR_DS_CANT_MIX_MASTER_AND_REPS"); break;
        case  8332 :  sTempString   = _T("The operation cannot be performed because child objects exist. This operation can only be performed on a leaf object. ERROR_DS_CHILDREN_EXIST"); break;
        case  8333 :  sTempString   = _T("Directory object not found. ERROR_DS_OBJ_NOT_FOUND"); break;
        case  8334 :  sTempString   = _T("The aliased object is missing. ERROR_DS_ALIASED_OBJ_MISSING"); break;
        case  8335 :  sTempString   = _T("The object name has bad syntax. ERROR_DS_BAD_NAME_SYNTAX"); break;
        case  8336 :  sTempString   = _T("It is not permitted for an alias to refer to another alias.  ERROR_DS_ALIAS_POINTS_TO_ALIAS"); break;
        case  8337 :  sTempString   = _T("The alias cannot be dereferenced. ERROR_DS_CANT_DEREF_ALIAS"); break;
        case  8338 :  sTempString   = _T("The operation is out of scope. ERROR_DS_OUT_OF_SCOPE"); break;
        case  8340 :  sTempString   = _T("The DSA object cannot be deleted. ERROR_DS_CANT_DELETE_DSA_OBJ"); break;
        case  8341 :  sTempString   = _T("A directory service error has occurred. ERROR_DS_GENERIC_ERROR"); break;
        case  8342 :  sTempString   = _T("The operation can only be performed on an internal master DSA object. ERROR_DS_DSA_MUST_BE_INT_MASTER"); break;
        case  8343 :  sTempString   = _T("The object must be of class DSA. ERROR_DS_CLASS_NOT_DSA"); break;
        case  8344 :  sTempString   = _T("Insufficient access rights to perform the operation. ERROR_DS_INSUFF_ACCESS_RIGHTS"); break;
        case  8345 :  sTempString   = _T("The object cannot be added because the parent is not on the list of possible superiors.  ERROR_DS_ILLEGAL_SUPERIOR"); break;
        case  8346 :  sTempString   = _T("Access to the attribute is not permitted because the attribute is owned by the Security Accounts Manager (SAM).  ERROR_DS_ATTRIBUTE_OWNED_BY_SAM"); break;
        case  8347 :  sTempString   = _T("The name has too many parts. ERROR_DS_NAME_TOO_MANY_PARTS"); break;
        case  8348 :  sTempString   = _T("The name is too long.  ERROR_DS_NAME_TOO_LONG"); break;
        case  8349 :  sTempString   = _T("The name value is too long. ERROR_DS_NAME_VALUE_TOO_LONG"); break;
        case  8350 :  sTempString   = _T("The directory service encountered an error parsing a name.  ERROR_DS_NAME_UNPARSEABLE"); break;
        case  8351 :  sTempString   = _T("The directory service cannot get the attribute type for a name.  ERROR_DS_NAME_TYPE_UNKNOWN"); break;
        case  8352 :  sTempString   = _T("The name does not identify an object; the name identifies a phantom. ERROR_DS_NOT_AN_OBJECT"); break;
        case  8353 :  sTempString   = _T("The security descriptor is too short. ERROR_DS_SEC_DESC_TOO_SHORT"); break;
        case  8354 :  sTempString   = _T("The security descriptor is invalid. ERROR_DS_SEC_DESC_INVALID"); break;
        case  8355 :  sTempString   = _T("Failed to create name for deleted object. ERROR_DS_NO_DELETED_NAME"); break;
        case  8356 :  sTempString   = _T("The parent of a new subref must exist. ERROR_DS_SUBREF_MUST_HAVE_PARENT"); break;
        case  8357 :  sTempString   = _T("The object must be a naming context. ERROR_DS_NCNAME_MUST_BE_NC"); break;
        case  8358 :  sTempString   = _T("It is not permitted to add an attribute which is owned by the system. ERROR_DS_CANT_ADD_SYSTEM_ONLY"); break;
        case  8359 :  sTempString   = _T("The class of the object must be structural; you cannot instantiate an abstract class.  ERROR_DS_CLASS_MUST_BE_CONCRETE"); break;
        case  8360 :  sTempString   = _T("The schema object could not be found. ERROR_DS_INVALID_DMD"); break;
        case  8361 :  sTempString   = _T("A local object with this GUID (dead or alive) already exists. ERROR_DS_OBJ_GUID_EXISTS"); break;
        case  8362 :  sTempString   = _T("The operation cannot be performed on a back link. ERROR_DS_NOT_ON_BACKLINK"); break;
        case  8363 :  sTempString   = _T("The cross reference for the specified naming context could not be found. ERROR_DS_NO_CROSSREF_FOR_NC"); break;
        case  8364 :  sTempString   = _T("The operation could not be performed because the directory service is shutting down. ERROR_DS_SHUTTING_DOWN"); break;
        case  8365 :  sTempString   = _T("The directory service request is invalid.  ERROR_DS_UNKNOWN_OPERATION"); break;
        case  8366 :  sTempString   = _T("The role owner attribute could not be read. ERROR_DS_INVALID_ROLE_OWNER"); break;
        case  8367 :  sTempString   = _T("The requested FSMO operation failed. The current FSMO holder could not be reached.  ERROR_DS_COULDNT_CONTACT_FSMO"); break;
        case  8368 :  sTempString   = _T("Modification of a DN across a naming context is not permitted. ERROR_DS_CROSS_NC_DN_RENAME"); break;
        case  8369 :  sTempString   = _T("The attribute cannot be modified because it is owned by the system. ERROR_DS_CANT_MOD_SYSTEM_ONLY"); break;
        case  8370 :  sTempString   = _T("Only the replicator can perform this function. ERROR_DS_REPLICATOR_ONLY"); break;
        case  8371 :  sTempString   = _T("The specified class is not defined. ERROR_DS_OBJ_CLASS_NOT_DEFINED"); break;
        case  8372 :  sTempString   = _T("The specified class is not a subclass. ERROR_DS_OBJ_CLASS_NOT_SUBCLASS"); break;
        case  8373 :  sTempString   = _T("The name reference is invalid. ERROR_DS_NAME_REFERENCE_INVALID"); break;
        case  8374 :  sTempString   = _T("A cross reference already exists. ERROR_DS_CROSS_REF_EXISTS"); break;
        case  8375 :  sTempString   = _T("It is not permitted to delete a master cross reference. ERROR_DS_CANT_DEL_MASTER_CROSSREF"); break;
        case  8376 :  sTempString   = _T("Subtree notifications are only supported on NC heads. ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD"); break;
        case  8377 :  sTempString   = _T("Notification filter is too complex. ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX"); break;
        case  8378 :  sTempString   = _T("Schema update failed: duplicate RDN.  ERROR_DS_DUP_RDN"); break;
        case  8379 :  sTempString   = _T("Schema update failed: duplicate OID  ERROR_DS_DUP_OID"); break;
        case  8380 :  sTempString   = _T("Schema update failed: duplicate MAPI identifier.  ERROR_DS_DUP_MAPI_ID"); break;
        case  8381 :  sTempString   = _T("Schema update failed: duplicate schema-id GUID.  ERROR_DS_DUP_SCHEMA_ID_GUID"); break;
        case  8382 :  sTempString   = _T("Schema update failed: duplicate LDAP display name.  ERROR_DS_DUP_LDAP_DISPLAY_NAME"); break;
        case  8383 :  sTempString   = _T("Schema update failed: range-lower less than range upper  ERROR_DS_SEMANTIC_ATT_TEST"); break;
        case  8384 :  sTempString   = _T("Schema update failed: syntax mismatch  ERROR_DS_SYNTAX_MISMATCH"); break;
        case  8385 :  sTempString   = _T("Schema deletion failed: attribute is used in must-contain  ERROR_DS_EXISTS_IN_MUST_HAVE"); break;
        case  8386 :  sTempString   = _T("Schema deletion failed: attribute is used in may-contain  ERROR_DS_EXISTS_IN_MAY_HAVE"); break;
        case  8387 :  sTempString   = _T("Schema update failed: attribute in may-contain does not exist  ERROR_DS_NONEXISTENT_MAY_HAVE"); break;
        case  8388 :  sTempString   = _T("Schema update failed: attribute in must-contain does not exist  ERROR_DS_NONEXISTENT_MUST_HAVE"); break;
        case  8389 :  sTempString   = _T("Schema update failed: class in aux-class list does not exist or is not an auxiliary class  ERROR_DS_AUX_CLS_TEST_FAIL"); break;
        case  8390 :  sTempString   = _T("Schema update failed: class in poss-superiors does not exist  ERROR_DS_NONEXISTENT_POSS_SUP"); break;
        case  8391 :  sTempString   = _T("Schema update failed: class in subclassof list does not exist or does not satisfy hierarchy rules  ERROR_DS_SUB_CLS_TEST_FAIL"); break;
        case  8392 :  sTempString   = _T("Schema update failed: Rdn-Att-Id has wrong syntax  ERROR_DS_BAD_RDN_ATT_ID_SYNTAX"); break;
        case  8393 :  sTempString   = _T("Schema deletion failed: class is used as auxiliary class  ERROR_DS_EXISTS_IN_AUX_CLS"); break;
        case  8394 :  sTempString   = _T("Schema deletion failed: class is used as sub class  ERROR_DS_EXISTS_IN_SUB_CLS"); break;
        case  8395 :  sTempString   = _T("Schema deletion failed: class is used as poss superior  ERROR_DS_EXISTS_IN_POSS_SUP"); break;
        case  8396 :  sTempString   = _T("Schema update failed in recalculating validation cache.  ERROR_DS_RECALCSCHEMA_FAILED"); break;
        case  8397 :  sTempString   = _T("The tree deletion is not finished. ERROR_DS_TREE_DELETE_NOT_FINISHED"); break;
        case  8398 :  sTempString   = _T("The requested delete operation could not be performed. ERROR_DS_CANT_DELETE"); break;
        case  8399 :  sTempString   = _T("Cannot read the governs class identifier for the schema record. ERROR_DS_ATT_SCHEMA_REQ_ID"); break;
        case  8400 :  sTempString   = _T("The attribute schema has bad syntax. ERROR_DS_BAD_ATT_SCHEMA_SYNTAX"); break;
        case  8401 :  sTempString   = _T("The attribute could not be cached. ERROR_DS_CANT_CACHE_ATT"); break;
        case  8402 :  sTempString   = _T("The class could not be cached. ERROR_DS_CANT_CACHE_CLASS"); break;
        case  8403 :  sTempString   = _T("The attribute could not be removed from the cache. ERROR_DS_CANT_REMOVE_ATT_CACHE"); break;
        case  8404 :  sTempString   = _T("The class could not be removed from the cache. ERROR_DS_CANT_REMOVE_CLASS_CACHE"); break;
        case  8405 :  sTempString   = _T("The distinguished name attribute could not be read. ERROR_DS_CANT_RETRIEVE_DN"); break;
        case  8406 :  sTempString   = _T("A required subref is missing. ERROR_DS_MISSING_SUPREF"); break;
        case  8407 :  sTempString   = _T("The instance type attribute could not be retrieved. ERROR_DS_CANT_RETRIEVE_INSTANCE"); break;
        case  8408 :  sTempString   = _T("An internal error has occurred. ERROR_DS_CODE_INCONSISTENCY"); break;
        case  8409 :  sTempString   = _T("A database error has occurred. ERROR_DS_DATABASE_ERROR"); break;
        case  8410 :  sTempString   = _T("The attribute GOVERNSID is missing. ERROR_DS_GOVERNSID_MISSING"); break;
        case  8411 :  sTempString   = _T("An expected attribute is missing. ERROR_DS_MISSING_EXPECTED_ATT"); break;
        case  8412 :  sTempString   = _T("The specified naming context is missing a cross reference. ERROR_DS_NCNAME_MISSING_CR_REF"); break;
        case  8413 :  sTempString   = _T("A security checking error has occurred. ERROR_DS_SECURITY_CHECKING_ERROR"); break;
        case  8414 :  sTempString   = _T("The schema is not loaded. ERROR_DS_SCHEMA_NOT_LOADED"); break;
        case  8415 :  sTempString   = _T("Schema allocation failed. Please check if the machine is running low on memory.  ERROR_DS_SCHEMA_ALLOC_FAILED"); break;
        case  8416 :  sTempString   = _T("Failed to obtain the required syntax for the attribute schema. ERROR_DS_ATT_SCHEMA_REQ_SYNTAX"); break;
        case  8417 :  sTempString   = _T("The global catalog verification failed. The global catalog is not available or does not support the operation. Some part of the directory is currently not available. ERROR_DS_GCVERIFY_ERROR"); break;
        case  8418 :  sTempString   = _T("The replication operation failed because of a schema mismatch between the servers involved.  ERROR_DS_DRA_SCHEMA_MISMATCH"); break;
        case  8419 :  sTempString   = _T("The DSA object could not be found. ERROR_DS_CANT_FIND_DSA_OBJ"); break;
        case  8420 :  sTempString   = _T("The naming context could not be found. ERROR_DS_CANT_FIND_EXPECTED_NC"); break;
        case  8421 :  sTempString   = _T("The naming context could not be found in the cache. ERROR_DS_CANT_FIND_NC_IN_CACHE"); break;
        case  8422 :  sTempString   = _T("The child object could not be retrieved. ERROR_DS_CANT_RETRIEVE_CHILD"); break;
        case  8423 :  sTempString   = _T("The modification was not permitted for security reasons. ERROR_DS_SECURITY_ILLEGAL_MODIFY"); break;
        case  8424 :  sTempString   = _T("The operation cannot replace the hidden record. ERROR_DS_CANT_REPLACE_HIDDEN_REC"); break;
        case  8425 :  sTempString   = _T("The hierarchy file is invalid. ERROR_DS_BAD_HIERARCHY_FILE"); break;
        case  8426 :  sTempString   = _T("The attempt to build the hierarchy table failed. ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED"); break;
        case  8427 :  sTempString   = _T("The directory configuration parameter is missing from the registry. ERROR_DS_CONFIG_PARAM_MISSING"); break;
        case  8428 :  sTempString   = _T("The attempt to count the address book indices failed. ERROR_DS_COUNTING_AB_INDICES_FAILED"); break;
        case  8429 :  sTempString   = _T("The allocation of the hierarchy table failed. ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED"); break;
        case  8430 :  sTempString   = _T("The directory service encountered an internal failure.  ERROR_DS_INTERNAL_FAILURE"); break;
        case  8431 :  sTempString   = _T("The directory service encountered an unknown failure.  ERROR_DS_UNKNOWN_ERROR"); break;
        case  8432 :  sTempString   = _T("A root object requires a class of 'top'. ERROR_DS_ROOT_REQUIRES_CLASS_TOP"); break;
        case  8433 :  sTempString   = _T("This directory server is shutting down, and cannot take ownership of new floating single-master operation roles.  ERROR_DS_REFUSING_FSMO_ROLES"); break;
        case  8434 :  sTempString   = _T("The directory service is missing mandatory configuration information, and is unable to determine the ownership of floating single-master operation roles.  ERROR_DS_MISSING_FSMO_SETTINGS"); break;
        case  8435 :  sTempString   = _T("The directory service was unable to transfer ownership of one or more floating single-master operation roles to other servers.  ERROR_DS_UNABLE_TO_SURRENDER_ROLES"); break;
        case  8436 :  sTempString   = _T("The replication operation failed.  ERROR_DS_DRA_GENERIC"); break;
        case  8437 :  sTempString   = _T("An invalid parameter was specified for this replication operation.  ERROR_DS_DRA_INVALID_PARAMETER"); break;
        case  8438 :  sTempString   = _T("The directory service is too busy to complete the replication operation at this time.  ERROR_DS_DRA_BUSY"); break;
        case  8439 :  sTempString   = _T("The distinguished name specified for this replication operation is invalid.  ERROR_DS_DRA_BAD_DN"); break;
        case  8440 :  sTempString   = _T("The naming context specified for this replication operation is invalid.  ERROR_DS_DRA_BAD_NC"); break;
        case  8441 :  sTempString   = _T("The distinguished name specified for this replication operation already exists.  ERROR_DS_DRA_DN_EXISTS"); break;
        case  8442 :  sTempString   = _T("The replication system encountered an internal error.  ERROR_DS_DRA_INTERNAL_ERROR"); break;
        case  8443 :  sTempString   = _T("The replication operation encountered a database inconsistency.  ERROR_DS_DRA_INCONSISTENT_DIT"); break;
        case  8444 :  sTempString   = _T("The server specified for this replication operation could not be contacted.  ERROR_DS_DRA_CONNECTION_FAILED"); break;
        case  8445 :  sTempString   = _T("The replication operation encountered an object with an invalid instance type.  ERROR_DS_DRA_BAD_INSTANCE_TYPE"); break;
        case  8446 :  sTempString   = _T("The replication operation failed to allocate memory.  ERROR_DS_DRA_OUT_OF_MEM"); break;
        case  8447 :  sTempString   = _T("The replication operation encountered an error with the mail system.  ERROR_DS_DRA_MAIL_PROBLEM"); break;
        case  8448 :  sTempString   = _T("The replication reference information for the target server already exists.  ERROR_DS_DRA_REF_ALREADY_EXISTS"); break;
        case  8449 :  sTempString   = _T("The replication reference information for the target server does not exist.  ERROR_DS_DRA_REF_NOT_FOUND"); break;
        case  8450 :  sTempString   = _T("The naming context cannot be removed because it is replicated to another server.  ERROR_DS_DRA_OBJ_IS_REP_SOURCE"); break;
        case  8451 :  sTempString   = _T("The replication operation encountered a database error.  ERROR_DS_DRA_DB_ERROR"); break;
        case  8452 :  sTempString   = _T("The naming context is in the process of being removed or is not replicated from the specified server.  ERROR_DS_DRA_NO_REPLICA"); break;
        case  8453 :  sTempString   = _T("Replication access was denied.  ERROR_DS_DRA_ACCESS_DENIED"); break;
        case  8454 :  sTempString   = _T("The requested operation is not supported by this version of the directory service.  ERROR_DS_DRA_NOT_SUPPORTED"); break;
        case  8455 :  sTempString   = _T("The replication remote procedure call was cancelled.  ERROR_DS_DRA_RPC_CANCELLED"); break;
        case  8456 :  sTempString   = _T("The source server is currently rejecting replication requests.  ERROR_DS_DRA_SOURCE_DISABLED"); break;
        case  8457 :  sTempString   = _T("The destination server is currently rejecting replication requests.  ERROR_DS_DRA_SINK_DISABLED"); break;
        case  8458 :  sTempString   = _T("The replication operation failed due to a collision of object names.  ERROR_DS_DRA_NAME_COLLISION"); break;
        case  8459 :  sTempString   = _T("The replication source has been reinstalled.  ERROR_DS_DRA_SOURCE_REINSTALLED"); break;
        case  8460 :  sTempString   = _T("The replication operation failed because a required parent object is missing.  ERROR_DS_DRA_MISSING_PARENT"); break;
        case  8461 :  sTempString   = _T("The replication operation was preempted.  ERROR_DS_DRA_PREEMPTED"); break;
        case  8462 :  sTempString   = _T("The replication synchronization attempt was abandoned because of a lack of updates.  ERROR_DS_DRA_ABANDON_SYNC"); break;
        case  8463 :  sTempString   = _T("The replication operation was terminated because the system is shutting down.  ERROR_DS_DRA_SHUTDOWN"); break;
        case  8464 :  sTempString   = _T("The replication synchronization attempt failed as the destination partial attribute set is not a subset of source partial attribute set.  ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET"); break;
        case  8465 :  sTempString   = _T("The replication synchronization attempt failed because a master replica attempted to sync from a partial replica.  ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA"); break;
        case  8466 :  sTempString   = _T("The server specified for this replication operation was contacted, but that server was unable to contact an additional server needed to complete the operation.  ERROR_DS_DRA_EXTN_CONNECTION_FAILED"); break;
        case  8467 :  sTempString   = _T("A schema mismatch is detected between the source and the build used during a replica install. The replica cannot be installed.  ERROR_DS_INSTALL_SCHEMA_MISMATCH"); break;
        case  8468 :  sTempString   = _T("Schema update failed: An attribute with the same link identifier already exists.  ERROR_DS_DUP_LINK_ID"); break;
        case  8469 :  sTempString   = _T("Name translation: Generic processing error.  ERROR_DS_NAME_ERROR_RESOLVING"); break;
        case  8470 :  sTempString   = _T("Name translation: Could not find the name or insufficient right to see name.  ERROR_DS_NAME_ERROR_NOT_FOUND"); break;
        case  8471 :  sTempString   = _T("Name translation: Input name mapped to more than one output name.  ERROR_DS_NAME_ERROR_NOT_UNIQUE"); break;
        case  8472 :  sTempString   = _T("Name translation: Input name found, but not the associated output format.  ERROR_DS_NAME_ERROR_NO_MAPPING"); break;
        case  8473 :  sTempString   = _T("Name translation: Unable to resolve completely, only the domain was found.  ERROR_DS_NAME_ERROR_DOMAIN_ONLY"); break;
        case  8474 :  sTempString   = _T("Name translation: Unable to perform purely syntactical mapping at the client without going out to the wire.  ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING"); break;
        case  8475 :  sTempString   = _T("Modification of a constructed att is not allowed.  ERROR_DS_CONSTRUCTED_ATT_MOD"); break;
        case  8476 :  sTempString   = _T("The OM-Object-Class specified is incorrect for an attribute with the specified syntax.  ERROR_DS_WRONG_OM_OBJ_CLASS"); break;
        case  8477 :  sTempString   = _T("The replication request has been posted; waiting for reply.  ERROR_DS_DRA_REPL_PENDING"); break;
        case  8478 :  sTempString   = _T("The requested operation requires a directory service, and none was available. ERROR_DS_DS_REQUIRED"); break;
        case  8479 :  sTempString   = _T("The LDAP display name of the class or attribute contains non-ASCII characters. ERROR_DS_INVALID_LDAP_DISPLAY_NAME"); break;
        case  8480 :  sTempString   = _T("The requested search operation is only supported for base searches. ERROR_DS_NON_BASE_SEARCH"); break;
        case  8481 :  sTempString   = _T("The search failed to retrieve attributes from the database. ERROR_DS_CANT_RETRIEVE_ATTS"); break;
        case  8482 :  sTempString   = _T("The schema update operation tried to add a backward link attribute that has no corresponding forward link. ERROR_DS_BACKLINK_WITHOUT_LINK"); break;
        case  8483 :  sTempString   = _T("Source and destination of a cross domain move do not agree on the object's epoch number. Either source or destination does not have the latest version of the object. ERROR_DS_EPOCH_MISMATCH"); break;
        case  8484 :  sTempString   = _T("Source and destination of a cross domain move do not agree on the object's current name. Either source or destination does not have the latest version of the object. ERROR_DS_SRC_NAME_MISMATCH"); break;
        case  8485 :  sTempString   = _T("Source and destination of a cross domain move operation are identical. Caller should use local move operation instead of cross domain move operation. ERROR_DS_SRC_AND_DST_NC_IDENTICAL"); break;
        case  8486 :  sTempString   = _T("Source and destination for a cross domain move are not in agreement on the naming contexts in the forest. Either source or destination does not have the latest version of the Partitions container. ERROR_DS_DST_NC_MISMATCH"); break;
        case  8487 :  sTempString   = _T("Destination of a cross domain move is not authoritative for the destination naming context. ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC"); break;
        case  8488 :  sTempString   = _T("Source and destination of a cross domain move do not agree on the identity of the source object. Either source or destination does not have the latest version of the source object. ERROR_DS_SRC_GUID_MISMATCH"); break;
        case  8489 :  sTempString   = _T("Object being moved across domains is already known to be deleted by the destination server. The source server does not have the latest version of the source object. ERROR_DS_CANT_MOVE_DELETED_OBJECT"); break;
        case  8490 :  sTempString   = _T("Another operation which requires exclusive access to the PDC PSMO is already in progress.  ERROR_DS_PDC_OPERATION_IN_PROGRESS"); break;
        case  8491 :  sTempString   = _T("A cross domain move operation failed such that the two versions of the moved object exist - one each in the source and destination domains. The destination object needs to be removed to restore the system to a consistent state. ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD"); break;
        case  8492 :  sTempString   = _T("This object may not be moved across domain boundaries either because cross domain moves for this class are disallowed, or the object has some special characteristics, eg: trust account or restricted RID, which prevent its move. ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION"); break;
        case  8493 :  sTempString   = _T("Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group. Remove the object from any account group memberships and retry. ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS"); break;
        case  8494 :  sTempString   = _T("A naming context head must be the immediate child of another naming context head, not of an interior node. ERROR_DS_NC_MUST_HAVE_NC_PARENT"); break;
        case  8495 :  sTempString   = _T("The directory cannot validate the proposed naming context name because it does not hold a replica of the naming context above the proposed naming context. Please ensure that the domain naming master role is held by a server that is configured as a global catalog server, and that the server is up to date with its replication partners. ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE"); break;
        case  8496 :  sTempString   = _T("Destination domain must be in native mode. ERROR_DS_DST_DOMAIN_NOT_NATIVE"); break;
        case  8497 :  sTempString   = _T("The operation can not be performed because the server does not have an infrastructure container in the domain of interest. ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER"); break;
        case  8498 :  sTempString   = _T("Cross domain move of account groups is not allowed. ERROR_DS_CANT_MOVE_ACCOUNT_GROUP"); break;
        case  8499 :  sTempString   = _T("Cross domain move of resource groups is not allowed. ERROR_DS_CANT_MOVE_RESOURCE_GROUP"); break;
        case  8500 :  sTempString   = _T("The search flags for the attribute are invalid. The ANR bit is valid only on attributes of Unicode or Teletex strings. ERROR_DS_INVALID_SEARCH_FLAG"); break;
        case  8501 :  sTempString   = _T("Tree deletions starting at an object which has an NC head as a descendant are not allowed. ERROR_DS_NO_TREE_DELETE_ABOVE_NC"); break;
        case  8502 :  sTempString   = _T("The directory service failed to lock a tree in preparation for a tree deletion because the tree was in use. ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE"); break;
        case  8503 :  sTempString   = _T("The directory service failed to identify the list of objects to delete while attempting a tree deletion.  ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE"); break;
        case  8504 :  sTempString   = _T("Security Accounts Manager initialization failed because of the following error: %%1. Error Status: 0x%%2. Click OK to shut down the system and reboot into Directory Services Restore Mode. Check the event log for detailed information. ERROR_DS_SAM_INIT_FAILURE"); break;
        case  8505 :  sTempString   = _T("Only an administrator can modify the membership list of an administrative group.  ERROR_DS_SENSITIVE_GROUP_VIOLATION"); break;
        case  8506 :  sTempString   = _T("Cannot change the primary group ID of a domain controller account. ERROR_DS_CANT_MOD_PRIMARYGROUPID"); break;
        case  8507 :  sTempString   = _T("An attempt is made to modify the base schema. ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD"); break;
        case  8508 :  sTempString   = _T("Adding a new mandatory attribute to an existing class, deleting a mandatory attribute from an existing class, or adding an optional attribute to the special class Top that is not a backlink attribute (directly or through inheritance, for example, by adding or deleting an auxiliary class) is not allowed. ERROR_DS_NONSAFE_SCHEMA_CHANGE"); break;
        case  8509 :  sTempString   = _T("Schema update is not allowed on this DC. Either the registry key is not set or the DC is not the schema FSMO Role Owner. ERROR_DS_SCHEMA_UPDATE_DISALLOWED"); break;
        case  8510 :  sTempString   = _T("An object of this class cannot be created under the schema container. You can only create attribute-schema and class-schema objects under the schema container. ERROR_DS_CANT_CREATE_UNDER_SCHEMA"); break;
        case  8511 :  sTempString   = _T("The replica/child install failed to get the objectVersion attribute on the schema container on the source DC. Either the attribute is missing on the schema container or the credentials supplied do not have permission to read it. ERROR_DS_INSTALL_NO_SRC_SCH_VERSION"); break;
        case  8512 :  sTempString   = _T("The replica/child install failed to read the objectVersion attribute in the SCHEMA section of the file schema.ini in the system32 directory. ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE"); break;
        case  8513 :  sTempString   = _T("The specified group type is invalid. ERROR_DS_INVALID_GROUP_TYPE"); break;
        case  8514 :  sTempString   = _T("Cannot nest global groups in a mixed domain if the group is security-enabled.  ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN"); break;
        case  8515 :  sTempString   = _T("Cannot nest local groups in a mixed domain if the group is security-enabled. ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN"); break;
        case  8516 :  sTempString   = _T("A global group cannot have a local group as a member.  ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER"); break;
        case  8517 :  sTempString   = _T("A global group cannot have a universal group as a member.  ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER"); break;
        case  8518 :  sTempString   = _T("A universal group cannot have a local group as a member. ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER"); break;
        case  8519 :  sTempString   = _T("A global group cannot have a cross-domain member. ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER"); break;
        case  8520 :  sTempString   = _T("A local group cannot have another cross-domain local group as a member. ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER"); break;
        case  8521 :  sTempString   = _T("A group with primary members cannot change to a security-disabled group. ERROR_DS_HAVE_PRIMARY_MEMBERS"); break;
        case  8522 :  sTempString   = _T("The schema cache load failed to convert the string default SD on a class-schema object. ERROR_DS_STRING_SD_CONVERSION_FAILED"); break;
        case  8523 :  sTempString   = _T("Only DSAs configured to be Global Catalog servers should be allowed to hold the Domain Naming Master FSMO role. ERROR_DS_NAMING_MASTER_GC"); break;
        case  8524 :  sTempString   = _T("The DSA operation is unable to proceed because of a DNS lookup failure.  ERROR_DS_LOOKUP_FAILURE"); break;
        case  8525 :  sTempString   = _T("While processing a change to the DNS Host Name for an object, the Service Principal Name values could not be kept in sync.  ERROR_DS_COULDNT_UPDATE_SPNS"); break;
        case  8526 :  sTempString   = _T("The Security Descriptor attribute could not be read. ERROR_DS_CANT_RETRIEVE_SD"); break;
        case  8527 :  sTempString   = _T("The object requested was not found, but an object with that key was found. ERROR_DS_KEY_NOT_UNIQUE."); break;
        case  8528 :  sTempString   = _T("The syntax of the linked attributed being added is incorrect. Forward links can only have syntax 2.5.5.1, 2.5.5.7, and 2.5.5.14, and backlinks can only have syntax 2.5.5.1. ERROR_DS_WRONG_LINKED_ATT_SYNTAX"); break;
        case  8529 :  sTempString   = _T("Security Account Manager needs to get the boot password. ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD"); break;
        case  8530 :  sTempString   = _T("Security Account Manager needs to get the boot key from floppy disk. ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY"); break;
        case  8531 :  sTempString   = _T("Directory Service cannot start. ERROR_DS_CANT_START"); break;
        case  8532 :  sTempString   = _T("Directory Services could not start. ERROR_DS_INIT_FAILURE"); break;
        case  8533 :  sTempString   = _T("The connection between client and server requires packet privacy or better. ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION"); break;
        case  8534 :  sTempString   = _T("The source domain may not be in the same forest as destination. ERROR_DS_SOURCE_DOMAIN_IN_FOREST"); break;
        case  8535 :  sTempString   = _T("The destination domain must be in the forest. ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST"); break;
        case  8536 :  sTempString   = _T("The operation requires that destination domain auditing be enabled. ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED"); break;
        case  8537 :  sTempString   = _T("The operation couldn't locate a DC for the source domain. ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN"); break;
        case  8538 :  sTempString   = _T("The source object must be a group or user. ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER"); break;
        case  8539 :  sTempString   = _T("The source object's SID already exists in destination forest. ERROR_DS_SRC_SID_EXISTS_IN_FOREST"); break;
        case  8540 :  sTempString   = _T("The source and destination object must be of the same type. ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH"); break;
        case  8541 :  sTempString   = _T("Security Accounts Manager initialization failed because of the following error: %%1. Error Status: 0x%%2. Click OK to shut down the system and reboot into Safe Mode. Check the event log for detailed information. ERROR_SAM_INIT_FAILURE"); break;
        case  8542 :  sTempString   = _T("Schema information could not be included in the replication request. ERROR_DS_DRA_SCHEMA_INFO_SHIP"); break;
        case  8543 :  sTempString   = _T("The replication operation could not be completed due to a schema incompatibility. ERROR_DS_DRA_SCHEMA_CONFLICT"); break;
        case  8544 :  sTempString   = _T("The replication operation could not be completed due to a previous schema incompatibility. ERROR_DS_DRA_EARLIER_SCHEMA_CONLICT"); break;
        case  8545 :  sTempString   = _T("The replication update could not be applied because either the source or the destination has not yet received information regarding a recent cross-domain move operation. ERROR_DS_DRA_OBJ_NC_MISMATCH"); break;
        case  8546 :  sTempString   = _T("The requested domain could not be deleted because there exist domain controllers that still host this domain. ERROR_DS_NC_STILL_HAS_DSAS"); break;
        case  8547 :  sTempString   = _T("The requested operation can be performed only on a global catalog server. ERROR_DS_GC_REQUIRED"); break;
        case  8548 :  sTempString   = _T("A local group can only be a member of other local groups in the same domain. ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY"); break;
        case  8549 :  sTempString   = _T("Foreign security principals cannot be members of universal groups. ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS"); break;
        case  8550 :  sTempString   = _T("The attribute is not allowed to be replicated to the GC because of security reasons. ERROR_DS_CANT_ADD_TO_GC"); break;
        case  8551 :  sTempString   = _T("The checkpoint with the PDC could not be taken because there are too many modifications being processed currently. ERROR_DS_NO_CHECKPOINT_WITH_PDC"); break;
        case  8552 :  sTempString   = _T("The operation requires that source domain auditing be enabled. ERROR_DS_SOURCE_AUDITING_NOT_ENABLED"); break;
        case  8553 :  sTempString   = _T("Security principal objects can only be created inside domain naming contexts. ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC"); break;
        case  8554 :  sTempString   = _T("A Service Principal Name (SPN) could not be constructed because the provided hostname is not in the necessary format. ERROR_DS_INVALID_NAME_FOR_SPN"); break;
        case  8555 :  sTempString   = _T("A Filter was passed that uses constructed attributes. ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS"); break;
        case  8556 :  sTempString   = _T("The unicodePwd attribute value must be enclosed in double quotes. ERROR_DS_UNICODEPWD_NOT_IN_QUOTES"); break;
        case  8557 :  sTempString   = _T("Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.  ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"); break;
        case  8558 :  sTempString   = _T("For security reasons, the operation must be run on the destination DC. ERROR_DS_MUST_BE_RUN_ON_DST_DC"); break;
        case  8559 :  sTempString   = _T("For security reasons, the source DC must be Service Pack 4 or greater. ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER"); break;
        case  8560 :  sTempString   = _T("Critical Directory Service System objects cannot be deleted during tree delete operations. The tree delete may have been partially performed. ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ"); break;
        case  9001 :  sTempString   = _T("DNS server unable to interpret format.  DNS_ERROR_RCODE_FORMAT_ERROR"); break;
        case  9002 :  sTempString   = _T("DNS server failure.  DNS_ERROR_RCODE_SERVER_FAILURE"); break;
        case  9003 :  sTempString   = _T("DNS name does not exist.  DNS_ERROR_RCODE_NAME_ERROR"); break;
        case  9004 :  sTempString   = _T("DNS request not supported by name server.  DNS_ERROR_RCODE_NOT_IMPLEMENTED"); break;
        case  9005 :  sTempString   = _T("DNS operation refused.  DNS_ERROR_RCODE_REFUSED"); break;
        case  9006 :  sTempString   = _T("DNS name that ought not exist, does exist.  DNS_ERROR_RCODE_YXDOMAIN"); break;
        case  9007 :  sTempString   = _T("DNS RR set that ought not exist, does exist.  DNS_ERROR_RCODE_YXRRSET"); break;
        case  9008 :  sTempString   = _T("DNS RR set that ought to exist, does not exist.  DNS_ERROR_RCODE_NXRRSET"); break;
        case  9009 :  sTempString   = _T("DNS server not authoritative for zone.  DNS_ERROR_RCODE_NOTAUTH"); break;
        case  9010 :  sTempString   = _T("DNS name in update or prereq is not in zone.  DNS_ERROR_RCODE_NOTZONE"); break;
        case  9016 :  sTempString   = _T("DNS signature failed to verify.  DNS_ERROR_RCODE_BADSIG"); break;
        case  9017 :  sTempString   = _T("DNS bad key.  DNS_ERROR_RCODE_BADKEY"); break;
        case  9018 :  sTempString   = _T("DNS signature validity expired.  DNS_ERROR_RCODE_BADTIME"); break;
        case  9501 :  sTempString   = _T("No records found for given DNS query.  DNS_INFO_NO_RECORDS"); break;
        case  9502 :  sTempString   = _T("Bad DNS packet.  DNS_ERROR_BAD_PACKET"); break;
        case  9503 :  sTempString   = _T("No DNS packet.  DNS_ERROR_NO_PACKET"); break;
        case  9504 :  sTempString   = _T("DNS error, check rcode.  DNS_ERROR_RCODE"); break;
        case  9505 :  sTempString   = _T("Unsecured DNS packet.  DNS_ERROR_UNSECURE_PACKET"); break;
        case  9551 :  sTempString   = _T("Invalid DNS type.  DNS_ERROR_INVALID_TYPE"); break;
        case  9552 :  sTempString   = _T("Invalid IP address.  DNS_ERROR_INVALID_IP_ADDRESS"); break;
        case  9553 :  sTempString   = _T("Invalid property.  DNS_ERROR_INVALID_PROPERTY"); break;
        case  9554 :  sTempString   = _T("Try DNS operation again later.  DNS_ERROR_TRY_AGAIN_LATER"); break;
        case  9555 :  sTempString   = _T("Record for given name and type is not unique.  DNS_ERROR_NOT_UNIQUE"); break;
        case  9556 :  sTempString   = _T("DNS name does not comply with RFC specifications.  DNS_ERROR_NON_RFC_NAME"); break;
        case  9557 :  sTempString   = _T("DNS name is a fully-qualified DNS name.  DNS_STATUS_FQDN"); break;
        case  9558 :  sTempString   = _T("DNS name is dotted (multi-label).  DNS_STATUS_DOTTED_NAME"); break;
        case  9559 :  sTempString   = _T("DNS name is a single-part name.  DNS_STATUS_SINGLE_PART_NAME"); break;
        case  9560 :  sTempString   = _T("DSN name contains an invalid character. DNS_ERROR_INVALID_NAME_CHAR"); break;
        case  9561 :  sTempString   = _T("DNS name is entirely numeric. DNS_ERROR_NUMERIC_NAME"); break;
        case  9601 :  sTempString   = _T("DNS zone does not exist.  DNS_ERROR_ZONE_DOES_NOT_EXIST"); break;
        case  9602 :  sTempString   = _T("DNS zone information not available.  DNS_ERROR_NO_ZONE_INFO"); break;
        case  9603 :  sTempString   = _T("Invalid operation for DNS zone.  DNS_ERROR_INVALID_ZONE_OPERATION"); break;
        case  9604 :  sTempString   = _T("Invalid DNS zone configuration.  DNS_ERROR_ZONE_CONFIGURATION_ERROR"); break;
        case  9605 :  sTempString   = _T("DNS zone has no start of authority (SOA) record.  DNS_ERROR_ZONE_HAS_NO_SOA_RECORD"); break;
        case  9606 :  sTempString   = _T("DNS zone has no name server (NS) record.  DNS_ERROR_ZONE_HAS_NO_NS_RECORDS"); break;
        case  9607 :  sTempString   = _T("DNS zone is locked.  DNS_ERROR_ZONE_LOCKED"); break;
        case  9608 :  sTempString   = _T("DNS zone creation failed.  DNS_ERROR_ZONE_CREATION_FAILED"); break;
        case  9609 :  sTempString   = _T("DNS zone already exists.  DNS_ERROR_ZONE_ALREADY_EXISTS"); break;
        case  9610 :  sTempString   = _T("DNS automatic zone already exists.  DNS_ERROR_AUTOZONE_ALREADY_EXISTS"); break;
        case  9611 :  sTempString   = _T("Invalid DNS zone type.  DNS_ERROR_INVALID_ZONE_TYPE"); break;
        case  9612 :  sTempString   = _T("Secondary DNS zone requires master IP address.  DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP"); break;
        case  9613 :  sTempString   = _T("DNS zone not secondary.  DNS_ERROR_ZONE_NOT_SECONDARY"); break;
        case  9614 :  sTempString   = _T("Need secondary IP address.  DNS_ERROR_NEED_SECONDARY_ADDRESSES"); break;
        case  9615 :  sTempString   = _T("WINS initialization failed.  DNS_ERROR_WINS_INIT_FAILED"); break;
        case  9616 :  sTempString   = _T("Need WINS servers.  DNS_ERROR_NEED_WINS_SERVERS"); break;
        case  9617 :  sTempString   = _T("NBTSTAT initialization call failed.  DNS_ERROR_NBSTAT_INIT_FAILED"); break;
        case  9618 :  sTempString   = _T("Invalid delete of start of authority (SOA)  DNS_ERROR_SOA_DELETE_INVALID"); break;
        case  9651 :  sTempString   = _T("Primary DNS zone requires datafile.  DNS_ERROR_PRIMARY_REQUIRES_DATAFILE"); break;
        case  9652 :  sTempString   = _T("Invalid datafile name for DNS zone.  DNS_ERROR_INVALID_DATAFILE_NAME"); break;
        case  9653 :  sTempString   = _T("Failed to open datafile for DNS zone.  DNS_ERROR_DATAFILE_OPEN_FAILURE"); break;
        case  9654 :  sTempString   = _T("Failed to write datafile for DNS zone.  DNS_ERROR_FILE_WRITEBACK_FAILED"); break;
        case  9655 :  sTempString   = _T("Failure while reading datafile for DNS zone.  DNS_ERROR_DATAFILE_PARSING"); break;
        case  9701 :  sTempString   = _T("DNS record does not exist.  DNS_ERROR_RECORD_DOES_NOT_EXIST"); break;
        case  9702 :  sTempString   = _T("DNS record format error.  DNS_ERROR_RECORD_FORMAT"); break;
        case  9703 :  sTempString   = _T("Node creation failure in DNS.  DNS_ERROR_NODE_CREATION_FAILED"); break;
        case  9704 :  sTempString   = _T("Unknown DNS record type.  DNS_ERROR_UNKNOWN_RECORD_TYPE"); break;
        case  9705 :  sTempString   = _T("DNS record timed out.  DNS_ERROR_RECORD_TIMED_OUT"); break;
        case  9706 :  sTempString   = _T("Name not in DNS zone.  DNS_ERROR_NAME_NOT_IN_ZONE"); break;
        case  9707 :  sTempString   = _T("CNAME loop detected.  DNS_ERROR_CNAME_LOOP"); break;
        case  9708 :  sTempString   = _T("Node is a CNAME DNS record.  DNS_ERROR_NODE_IS_CNAME"); break;
        case  9709 :  sTempString   = _T("A CNAME record already exists for given name.  DNS_ERROR_CNAME_COLLISION"); break;
        case  9710 :  sTempString   = _T("Record only at DNS zone root.  DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT"); break;
        case  9711 :  sTempString   = _T("DNS record already exists.  DNS_ERROR_RECORD_ALREADY_EXISTS"); break;
        case  9712 :  sTempString   = _T("Secondary DNS zone data error.  DNS_ERROR_SECONDARY_DATA"); break;
        case  9713 :  sTempString   = _T("Could not create DNS cache data.  DNS_ERROR_NO_CREATE_CACHE_DATA"); break;
        case  9714 :  sTempString   = _T("DNS name does not exist.  DNS_ERROR_NAME_DOES_NOT_EXIST"); break;
        case  9715 :  sTempString   = _T("Could not create pointer (PTR) record.  DNS_WARNING_PTR_CREATE_FAILED"); break;
        case  9716 :  sTempString   = _T("DNS domain was undeleted.  DNS_WARNING_DOMAIN_UNDELETED"); break;
        case  9717 :  sTempString   = _T("The directory service is unavailable.  DNS_ERROR_DS_UNAVAILABLE"); break;
        case  9718 :  sTempString   = _T("DNS zone already exists in the directory service.  DNS_ERROR_DS_ZONE_ALREADY_EXISTS"); break;
        case  9719 :  sTempString   = _T("DNS server not creating or reading the boot file for the directory service integrated DNS zone.  DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE"); break;
        case  9751 :  sTempString   = _T("DNS AXFR (zone transfer) complete.  DNS_INFO_AXFR_COMPLETE"); break;
        case  9752 :  sTempString   = _T("DNS zone transfer failed.  DNS_ERROR_AXFR"); break;
        case  9753 :  sTempString   = _T("Added local WINS server.  DNS_INFO_ADDED_LOCAL_WINS"); break;
        case  9801 :  sTempString   = _T("Secure update call needs to continue update request.  DNS_STATUS_CONTINUE_NEEDED"); break;
        case  9851 :  sTempString   = _T("TCP/IP network protocol not installed.  DNS_ERROR_NO_TCPIP"); break;
        case  9852 :  sTempString   = _T("No DNS servers configured for local system.  DNS_ERROR_NO_DNS_SERVERS"); break;
        case 10004 :  sTempString   = _T("A blocking operation was interrupted by a call to WSACancelBlockingCall.  WSAEINTR"); break;
        case 10009 :  sTempString   = _T("The file handle supplied is not valid.  WSAEBADF"); break;
        case 10013 :  sTempString   = _T("An attempt was made to access a socket in a way forbidden by its access permissions.  WSAEACCES"); break;
        case 10014 :  sTempString   = _T("The system detected an invalid pointer address in attempting to use a pointer argument in a call.  WSAEFAULT"); break;
        case 10022 :  sTempString   = _T("An invalid argument was supplied.  WSAEINVAL"); break;
        case 10024 :  sTempString   = _T("Too many open sockets.  WSAEMFILE"); break;
        case 10035 :  sTempString   = _T("A non-blocking socket operation could not be completed immediately.  WSAEWOULDBLOCK"); break;
        case 10036 :  sTempString   = _T("A blocking operation is currently executing.  WSAEINPROGRESS"); break;
        case 10037 :  sTempString   = _T("An operation was attempted on a non-blocking socket that already had an operation in progress.  WSAEALREADY"); break;
        case 10038 :  sTempString   = _T("An operation was attempted on something that is not a socket.  WSAENOTSOCK"); break;
        case 10039 :  sTempString   = _T("A required address was omitted from an operation on a socket.  WSAEDESTADDRREQ"); break;
        case 10040 :  sTempString   = _T("A message sent on a datagram socket was larger than the internal message buffer or some other network limit, or the buffer used to receive a datagram into was smaller than the datagram itself.  WSAEMSGSIZE"); break;
        case 10041 :  sTempString   = _T("A protocol was specified in the socket function call that does not support the semantics of the socket type requested.  WSAEPROTOTYPE"); break;
        case 10042 :  sTempString   = _T("An unknown, invalid, or unsupported option or level was specified in a getsockopt or setsockopt call.  WSAENOPROTOOPT"); break;
        case 10043 :  sTempString   = _T("The requested protocol has not been configured into the system, or no implementation for it exists.  WSAEPROTONOSUPPORT"); break;
        case 10044 :  sTempString   = _T("The support for the specified socket type does not exist in this address family.  WSAESOCKTNOSUPPORT"); break;
        case 10045 :  sTempString   = _T("The attempted operation is not supported for the type of object referenced.  WSAEOPNOTSUPP"); break;
        case 10046 :  sTempString   = _T("The protocol family has not been configured into the system or no implementation for it exists.  WSAEPFNOSUPPORT"); break;
        case 10047 :  sTempString   = _T("An address incompatible with the requested protocol was used.  WSAEAFNOSUPPORT"); break;
        case 10048 :  sTempString   = _T("Only one usage of each socket address (protocol/network address/port) is normally permitted.  WSAEADDRINUSE"); break;
        case 10049 :  sTempString   = _T("The requested address is not valid in its context.  WSAEADDRNOTAVAIL"); break;
        case 10050 :  sTempString   = _T("A socket operation encountered a dead network.  WSAENETDOWN"); break;
        case 10051 :  sTempString   = _T("A socket operation was attempted to an unreachable network.  WSAENETUNREACH"); break;
        case 10052 :  sTempString   = _T("The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.  WSAENETRESET"); break;
        case 10053 :  sTempString   = _T("An established connection was aborted by the software in your host machine.  WSAECONNABORTED"); break;
        case 10054 :  sTempString   = _T("An existing connection was forcibly closed by the remote host.  WSAECONNRESET"); break;
        case 10055 :  sTempString   = _T("An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.  WSAENOBUFS"); break;
        case 10056 :  sTempString   = _T("A connect request was made on an already connected socket.  WSAEISCONN"); break;
        case 10057 :  sTempString   = _T("A request to send or receive data was disallowed because the socket is not connected and (when sending on a datagram socket using a sendto call) no address was supplied.  WSAENOTCONN"); break;
        case 10058 :  sTempString   = _T("A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call.  WSAESHUTDOWN"); break;
        case 10059 :  sTempString   = _T("Too many references to some kernel object.  WSAETOOMANYREFS"); break;
        case 10060 :  sTempString   = _T("A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.  WSAETIMEDOUT"); break;
        case 10061 :  sTempString   = _T("No connection could be made because the target machine actively refused it.  WSAECONNREFUSED"); break;
        case 10062 :  sTempString   = _T("Cannot translate name.  WSAELOOP"); break;
        case 10063 :  sTempString   = _T("Name component or name was too long.  WSAENAMETOOLONG"); break;
        case 10064 :  sTempString   = _T("A socket operation failed because the destination host was down.  WSAEHOSTDOWN"); break;
        case 10065 :  sTempString   = _T("A socket operation was attempted to an unreachable host.  WSAEHOSTUNREACH"); break;
        case 10066 :  sTempString   = _T("Cannot remove a directory that is not empty.  WSAENOTEMPTY"); break;
        case 10067 :  sTempString   = _T("A Windows Sockets implementation may have a limit on the number of applications that may use it simultaneously.  WSAEPROCLIM"); break;
        case 10068 :  sTempString   = _T("Ran out of quota.  WSAEUSERS"); break;
        case 10069 :  sTempString   = _T("Ran out of disk quota.  WSAEDQUOT"); break;
        case 10070 :  sTempString   = _T("File handle reference is no longer available.  WSAESTALE"); break;
        case 10071 :  sTempString   = _T("Item is not available locally.  WSAEREMOTE"); break;
        case 10091 :  sTempString   = _T("WSAStartup cannot function at this time because the underlying system it uses to provide network services is currently unavailable.  WSASYSNOTREADY"); break;
        case 10092 :  sTempString   = _T("The Windows Sockets version requested is not supported.  WSAVERNOTSUPPORTED"); break;
        case 10093 :  sTempString   = _T("Either the application has not called WSAStartup, or WSAStartup failed.  WSANOTINITIALISED"); break;
        case 10101 :  sTempString   = _T("Returned by WSARecv or WSARecvFrom to indicate the remote party has initiated a graceful shutdown sequence.  WSAEDISCON"); break;
        case 10102 :  sTempString   = _T("No more results can be returned by WSALookupServiceNext.  WSAENOMORE"); break;
        case 10103 :  sTempString   = _T("A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.  WSAECANCELLED"); break;
        case 10104 :  sTempString   = _T("The procedure call table is invalid.  WSAEINVALIDPROCTABLE"); break;
        case 10105 :  sTempString   = _T("The requested service provider is invalid.  WSAEINVALIDPROVIDER"); break;
        case 10106 :  sTempString   = _T("The requested service provider could not be loaded or initialized.  WSAEPROVIDERFAILEDINIT"); break;
        case 10107 :  sTempString   = _T("A system call that should never fail has failed.  WSASYSCALLFAILURE"); break;
        case 10108 :  sTempString   = _T("No such service is known. The service cannot be found in the specified name space.  WSASERVICE_NOT_FOUND"); break;
        case 10109 :  sTempString   = _T("The specified class was not found.  WSATYPE_NOT_FOUND"); break;
        case 10110 :  sTempString   = _T("No more results can be returned by WSALookupServiceNext.  WSA_E_NO_MORE"); break;
        case 10111 :  sTempString   = _T("A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled.  WSA_E_CANCELLED"); break;
        case 10112 :  sTempString   = _T("A database query failed because it was actively refused.  WSAEREFUSED"); break;
        case 11001 :  sTempString   = _T("No such host is known.  WSAHOST_NOT_FOUND"); break;
        case 11002 :  sTempString   = _T("This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server.  WSATRY_AGAIN"); break;
        case 11003 :  sTempString   = _T("A non-recoverable error occurred during a database lookup.  WSANO_RECOVERY"); break;
        case 11004 :  sTempString   = _T("The requested name is valid and was found in the database, but it does not have the correct associated data being resolved for.  WSANO_DATA"); break;
        case 11005 :  sTempString   = _T("At least one reserve has arrived.  WSA_QOS_RECEIVERS"); break;
        case 11006 :  sTempString   = _T("At least one path has arrived.  WSA_QOS_SENDERS"); break;
        case 11007 :  sTempString   = _T("There are no senders.  WSA_QOS_NO_SENDERS"); break;
        case 11008 :  sTempString   = _T("There are no receivers.  WSA_QOS_NO_RECEIVERS"); break;
        case 11009 :  sTempString   = _T("Reserve has been confirmed.  WSA_QOS_REQUEST_CONFIRMED"); break;
        case 11010 :  sTempString   = _T("Error due to lack of resources.  WSA_QOS_ADMISSION_FAILURE"); break;
        case 11011 :  sTempString   = _T("Rejected for administrative reasons - bad credentials.  WSA_QOS_POLICY_FAILURE"); break;
        case 11012 :  sTempString   = _T("Unknown or conflicting style.  WSA_QOS_BAD_STYLE"); break;
        case 11013 :  sTempString   = _T("Problem with some part of the filterspec or providerspecific buffer in general.  WSA_QOS_BAD_OBJECT"); break;
        case 11014 :  sTempString   = _T("Problem with some part of the flowspec.  WSA_QOS_TRAFFIC_CTRL_ERROR"); break;
        case 11015 :  sTempString   = _T("General QOS error.  WSA_QOS_GENERIC_ERROR"); break;
        case 11016 :  sTempString   = _T("An invalid or unrecognized service type was found in the flowspec. WSA_QOS_ESERVICETYPE"); break;
        case 11017 :  sTempString   = _T("An invalid or inconsistent flowspec was found in the QOS structure. WSA_QOS_EFLOWSPEC"); break;
        case 11018 :  sTempString   = _T("Invalid QOS provider-specific buffer. WSA_QOS_EPROVSPECBUF"); break;
        case 11019 :  sTempString   = _T("An invalid QOS filter style was used. WSA_QOS_EFILTERSTYLE"); break;
        case 11020 :  sTempString   = _T("An invalid QOS filter type was used. WSA_QOS_EFILTERTYPE"); break;
        case 11021 :  sTempString   = _T("An incorrect number of QOS FILTERSPECs were specified in the FLOWDESCRIPTOR. WSA_QOS_EFILTERCOUNT"); break;
        case 11022 :  sTempString   = _T("An object with an invalid ObjectLength field was specified in the QOS provider-specific buffer. WSA_QOS_EOBJLENGTH"); break;
        case 11023 :  sTempString   = _T("An incorrect number of flow descriptors was specified in the QOS structure. WSA_QOS_EFLOWCOUNT"); break;
        case 11024 :  sTempString   = _T("An unrecognized object was found in the QOS provider-specific buffer. WSA_QOS_EUNKNOWNPSOBJ"); break;
        case 11025 :  sTempString   = _T("An invalid policy object was found in the QOS provider-specific buffer. WSA_QOS_EPOLICYOBJ"); break;
        case 11026 :  sTempString   = _T("An invalid QOS flow descriptor was found in the flow descriptor list. WSA_QOS_EFLOWDESC"); break;
        case 11027 :  sTempString   = _T("An invalid or inconsistent flowspec was found in the QOS provider-specific buffer. WSA_QOS_EPSFLOWSPEC"); break;
        case 11028 :  sTempString   = _T("An invalid FILTERSPEC was found in the QOS provider-specific buffer. WSA_QOS_EPSFILTERSPEC"); break;
        case 11029 :  sTempString   = _T("An invalid shape discard mode object was found in the QOS provider-specific buffer. WSA_QOS_ESDMODEOBJ"); break;
        case 11030 :  sTempString   = _T("An invalid shaping rate object was found in the QOS provider-specific buffer. WSA_QOS_ESHAPERATEOBJ"); break;
        case 11031 :  sTempString   = _T("A reserved policy element was found in the QOS provider-specific buffer. WSA"); break;
        default    :  sTempString   = _T("Error string not found."); break;
        }

    sTempString.CopyTo(sErrorString);

    return S_OK;
}//DMS_WinErrorMsg::GetErrorString
