/* EVENTLOG.CPP - Implementation file for Eventlog class
Copyright:   (C) Sigmex BV, 2000. All rights reserved.

    Wrapper class for the EventLog API

History:
    [00]    HB  16Jun00 Derived from "Windows NT in Practice"

*/

#include "stdafx.h"
#include "eventlog.h"

#define EVENT_APP  _T("SYSTEM\\CurrentControlSet\\Services\
\\EventLog\\Application\\")

/* Default constructor
*/
EventLog::EventLog()
{
    bClearReg = FALSE;
    szRegKey[0] = '\0';
    szSource[0] = '\0';
}

/* Specific constructor
   
   Input : szSourceName - the source for the events, usually the
                          module name, saved in the registry
           szMessageFile- DLL (or EXE) with message resource
                          generated by message compiler
           bClearOnExit - if TRUE, remove source from registry
                          in destructor
   Output: dwStatus     - TRUE if success
*/
EventLog::EventLog(TCHAR *szSourceName, TCHAR *szMessageFile,
   BOOL bClearOnExit, DWORD *dwStatus)
{
   TCHAR szMessageDllPath[MAX_PATH];
   
   bClearReg = bClearOnExit;
   _tcscpy(szSource, szSourceName);

   _tcscpy(szMessageDllPath, _T("%SystemRoot%\\System32\\"));
   _tcscat(szMessageDllPath, szMessageFile);

   if (dwStatus)
      *dwStatus = RegisterSource(szSource, szMessageDllPath);
   else 
      RegisterSource(szSource, szMessageDllPath);

} // EventLog::EventLog

/* Destructor
*/
EventLog::~EventLog()
{
   if (bClearReg && szSource[0]) {
       UnregisterSource(szSource);
   }
} // EventLog::~EventLog

/* RegisterSource - Register a source for the events

   Input : szSource     - the source for the events, usually the
                          module name, saved in the registry
           szMessageFile- DLL (or EXE) with message resource
                          generated by message compiler

   Returns: TRUE if success
*/
BOOL EventLog::RegisterSource(TCHAR *szSource, TCHAR *szMessageFile)
{

   HKEY  hKey;
   DWORD dwData;
   TCHAR szRegKey[MAX_PATH];
   BOOL  bStatus = FALSE;

   // just try creating it, if it exists, it will be opened
   _tcscpy(szRegKey, EVENT_APP);
   _tcscat(szRegKey, szSource);
   if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, _T("\0"),
                      REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS | KEY_WRITE, 
                      NULL, &hKey, &dwData) == ERROR_SUCCESS) {

      // add the message file value
      _tcscpy(szRegKey, szMessageFile);

	  int length = (_tcslen(szRegKey)+1) * sizeof(TCHAR); // handle Unicode strings

      RegSetValueEx(hKey, _T("EventMessageFile"), 0, REG_EXPAND_SZ,
                    (LPBYTE)szRegKey, length);

      // add the supported types value
      dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
               EVENTLOG_INFORMATION_TYPE ;
      RegSetValueEx(hKey, _T("TypesSupported"), 0, REG_DWORD, 
         (LPBYTE)&dwData, sizeof(DWORD));
      RegCloseKey(hKey);
      bStatus = TRUE;   
   } 

   return bStatus;
}

/* UnregisterSource - remove source from registry

   Input : szSource - the name of the source to remove.
*/
BOOL EventLog::UnregisterSource(TCHAR *szSource)
{
   HKEY  hKey;
   TCHAR szRegKey[MAX_PATH];
   // caller specified for registry entry to be removed
   _tcscpy(szRegKey, EVENT_APP);
   _tcscat(szRegKey, szSource);

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, EVENT_APP, 0, 
                    KEY_WRITE, &hKey) == ERROR_SUCCESS) {
      RegDeleteKey(hKey, szSource); 
      RegCloseKey(hKey);
   }

   return TRUE;
}

/* RegisterModule - Register the as the source

   Input : szModuleName - the name of the module
   Returns: TRUE if success
*/
BOOL EventLog::RegisterModule(TCHAR *szModuleName)
{
   TCHAR szModuleFileName[MAX_PATH] ;
   TCHAR szSource[MAX_PATH];

   szSource[0] = '\0';
   szModuleFileName[0] = '\0';

   if (::GetModuleFileName(::GetModuleHandle(szModuleName), 
                           szModuleFileName, 
                           MAX_PATH) != 0) {
      // Get the name of the binary executable from the full name
      _tsplitpath(szModuleFileName, NULL, NULL, szSource, NULL) ;
   }

   return RegisterSource(szSource, szModuleFileName);
}

/* UnregisterModule - Remove module from registry

   Returns: TRUE if success
*/
BOOL EventLog::UnregisterModule(TCHAR *szModuleName)
{
   TCHAR szModuleFileName[MAX_PATH] ;
   TCHAR szSource[MAX_PATH];

   szSource[0] = '\0';
   szModuleFileName[0] = '\0';

   if (::GetModuleFileName(::GetModuleHandle(szModuleName),
                           szModuleFileName, 
                           MAX_PATH) != 0) {
      // Get the name of the binary executable from the full name
      _tsplitpath(szModuleFileName, NULL, NULL, szSource, NULL) ;
   }

   return UnregisterSource(szSource);
}

/* UseSource - in all subsequent Write calls, use the module
               as the source
*/
void EventLog::UseSource(TCHAR *szSourceName)
{
   _tcscpy(szSource, szSourceName);
}

/* Backup - Backup the event log
*/
DWORD EventLog::Backup(LPTSTR szBackup)
{
   HANDLE hSource;

   if ((hSource = OpenEventLog(NULL, szSource)) != NULL) { 
      BackupEventLog(hSource, (LPCTSTR)szBackup);
      CloseEventLog(hSource);
      return TRUE;
   } else return FALSE;
} // EventLog::Backup

/* Clear - Clear the event log
*/
DWORD EventLog::Clear(LPTSTR szBackup)
{
   HANDLE hSource;

   if ((hSource = OpenEventLog(NULL, szSource)) != NULL) { 
      ClearEventLog(hSource, (LPCTSTR)szBackup);
      CloseEventLog(hSource);
      return TRUE;
   } else return FALSE;
} // EventLog::Clear

/* Query
*/
DWORD EventLog::Query(DWORD *dwNumRecords, DWORD *dwOldestRecord)
{
   HANDLE hSource;

   if ((hSource = OpenEventLog(NULL, szSource)) != NULL) { 
      GetNumberOfEventLogRecords(hSource, dwNumRecords);
      GetOldestEventLogRecord(hSource, dwOldestRecord);
      CloseEventLog(hSource);
      return TRUE;
   } else return FALSE;
} // EventLog::Query

/* Read
*/
DWORD EventLog::Read(DWORD dwRec, EVENTLOGRECORD *pData, 
   DWORD dwSize)
{
   HANDLE hSource;
   DWORD dwRead, dwRequired, dwStatus = TRUE;

   if ((hSource = OpenEventLog(NULL, szSource)) != NULL)
      return FALSE;
   if (!ReadEventLog(hSource, EVENTLOG_FORWARDS_READ | 
                     EVENTLOG_SEEK_READ, dwRec, pData, dwSize, &dwRead, 
                     &dwRequired)) dwStatus = dwRequired;
   CloseEventLog(hSource);
   return dwStatus;      
} // EventLog::Read

/* Write - write event to the event log

   Input : dwEventID  - event ID defined in message file
           wEventType - EVENTLOG_SUCCESS etc defined in winnt.h
           wStrings   - number of strings in array (pszStrings)
           pszStrings - array with insertion strings (%1 etc. in message text)
           dwData     - size of data buffer
           lpData     - data buffer

   Returns: TRUE if success
*/
DWORD EventLog::Write(DWORD dwEventID, WORD wEventType, 
   WORD wStrings, LPCTSTR *pszStrings, DWORD dwData, 
   LPBYTE lpData)
{
   HANDLE hSource;

   if ((hSource = RegisterEventSource(NULL, szSource)) != NULL) 
   {

     BOOL stat = ReportEvent(hSource, wEventType, 0, dwEventID, NULL, 
                  wStrings, dwData, pszStrings, lpData);
     if ( !stat )
     {
	      LPVOID lpMsgBuf;
		    DWORD status = GetLastError() ;

		    FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
									      FORMAT_MESSAGE_IGNORE_INSERTS,	NULL, status, 
									      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
									      (LPTSTR) &lpMsgBuf,0,NULL );

		    ATLTRACE(_T("%s\n"), lpMsgBuf ) ;

		    // Free the buffer.
		    LocalFree( lpMsgBuf );
     }

     DeregisterEventSource(hSource);

     return TRUE;

   } else return FALSE;      
} // EventLog::Write

/* WriteCustom - write custom string to the event log with ID = 0

   Input  :  pString    - string to write
             wEventType - EVENTLOG_SUCCESS etc. defined in winnt.h

   Returns: TRUE if success
*/
DWORD EventLog::WriteCustom(LPCTSTR pString, WORD wEventType)
{
   HANDLE hSource;

   if ((hSource = RegisterEventSource(NULL, szSource)) != NULL) {
      ReportEvent(hSource, wEventType, 0, 0, NULL, 1, 0, 
                  (LPCTSTR *)&pString, NULL);
      DeregisterEventSource(hSource);
      return TRUE;
   } else return FALSE;      
} // EventLog::WriteCustom

DWORD EventLog::WriteSimple(DWORD dwEventID, CComBSTR ErrorMessage)
{
	USES_CONVERSION;

	WORD wEventType = static_cast<WORD>( dwEventID >> 30 ); // The last two bits of the EventId determine the type

	LPCTSTR Error = OLE2CT(ErrorMessage);

	return Write(dwEventID, wEventType, 1, &Error, 0, 0);
}
